{
  "name": "MaiTribe - WF4 Conversation Summarizer",
  "nodes": [
    {
      "id": "wf4-cron",
      "name": "Cron Every 10 Minutes",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        -1280,
        240
      ],
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyX",
              "value": 10,
              "unit": "minutes"
            }
          ]
        }
      }
    },
    {
      "id": "wf4-select-stale",
      "name": "Select Stale Conversations",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1060,
        240
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "select c.id as conversation_id, c.user_id from public.conversations c where c.is_active = true and c.updated_at < now() - interval '30 minutes' and exists (select 1 from public.messages m where m.conversation_id = c.id) order by c.updated_at asc limit 100;",
        "options": {}
      }
    },
    {
      "id": "wf4-load-context",
      "name": "Load Conversation Context",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -840,
        240
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ \"select c.id as conversation_id, c.user_id, coalesce(u.language, 'en') as language, coalesce(u.display_name, u.name, 'friend') as display_name, coalesce((select json_agg(json_build_object('role', m.role, 'content', m.content, 'created_at', m.created_at) order by m.created_at asc) from public.messages m where m.conversation_id = c.id), '[]'::json) as messages from public.conversations c left join public.users u on u.id = c.user_id where c.id = '\" + $json.conversation_id + \"' limit 1;\" }}",
        "options": {}
      }
    },
    {
      "id": "wf4-build-transcript",
      "name": "Build Transcript + Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -620,
        240
      ],
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const row = $json;\n\nlet messages = row.messages;\nif (typeof messages === 'string') {\n  try {\n    messages = JSON.parse(messages);\n  } catch (e) {\n    messages = [];\n  }\n}\nif (!Array.isArray(messages)) messages = [];\n\nconst hasMessages = messages.length > 0;\nconst lang = String(row.language || 'en');\n\nconst transcript = messages\n  .map((m) => `${m.role === 'assistant' ? 'Mai' : 'User'}: ${String(m.content || '').replace(/\\s+/g, ' ').trim()}`)\n  .join('\\n');\n\nconst prompt = `Summarize this conversation in ${lang}.\nReturn strict JSON with keys summary, topics, mood.\nsummary max 90 words. topics as array of 3 to 8 lowercase tags. mood optional single word.\nNo markdown. Return valid JSON only.\nTranscript:\n${transcript}`;\n\nreturn [{\n  json: {\n    ...row,\n    messages,\n    has_messages: hasMessages,\n    transcript,\n    prompt,\n    fallback_summary: 'Conversation stored. Summary unavailable.'\n  }\n}];"
      }
    },
    {
      "id": "wf4-if-has-messages",
      "name": "Has Messages?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -400,
        240
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_messages }}"
            }
          ]
        }
      }
    },
    {
      "id": "wf4-gemini",
      "name": "Gemini Summarize",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -180,
        140
      ],
      "continueOnFail": true,
      "parameters": {
        "method": "POST",
        "url": "={{ 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + $env.GEMINI_API_KEY }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { system_instruction: { parts: [{ text: 'Return strict JSON only.' }] }, contents: [{ role: 'user', parts: [{ text: $json.prompt }] }], generationConfig: { temperature: 0.5, topP: 0.9, maxOutputTokens: 300 } } }}",
        "options": {}
      }
    },
    {
      "id": "wf4-merge-gemini",
      "name": "Merge Gemini + Payload",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        40,
        240
      ],
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      }
    },
    {
      "id": "wf4-parse-summary",
      "name": "Parse Summary JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        260,
        240
      ],
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const extractGeminiText = (obj) => {\n  if (!obj) return '';\n  if (obj.candidates && obj.candidates[0] && obj.candidates[0].content && Array.isArray(obj.candidates[0].content.parts)) {\n    return obj.candidates[0].content.parts.map((p) => p.text || '').join('\\n').trim();\n  }\n  if (obj.body && obj.body.candidates && obj.body.candidates[0] && obj.body.candidates[0].content && Array.isArray(obj.body.candidates[0].content.parts)) {\n    return obj.body.candidates[0].content.parts.map((p) => p.text || '').join('\\n').trim();\n  }\n  return '';\n};\n\nconst raw = extractGeminiText($json);\nlet parsed = null;\ntry {\n  parsed = JSON.parse(raw);\n} catch (e) {\n  parsed = null;\n}\n\nlet summary = parsed && typeof parsed.summary === 'string' ? parsed.summary.trim() : '';\nlet topics = parsed && Array.isArray(parsed.topics) ? parsed.topics.map((t) => String(t || '').trim().toLowerCase()).filter(Boolean) : [];\nlet mood = parsed && typeof parsed.mood === 'string' ? parsed.mood.trim().toLowerCase() : null;\n\nif (!summary) summary = $json.fallback_summary;\nif (!topics.length) topics = [];\n\nif (summary.length > 1200) summary = summary.slice(0, 1200);\nif (topics.length > 12) topics = topics.slice(0, 12);\n\nconst sqlLiteral = (value) => {\n  const escaped = String(value || '').replace(/'/g, String.fromCharCode(39, 39));\n  return String.fromCharCode(39) + escaped + String.fromCharCode(39);\n};\n\nreturn [{\n  json: {\n    ...$json,\n    summary,\n    topics,\n    mood,\n    summary_sql: sqlLiteral(summary),\n    topics_sql: sqlLiteral(JSON.stringify(topics)),\n    mood_sql: mood ? sqlLiteral(mood) : 'null'\n  }\n}];"
      }
    },
    {
      "id": "wf4-update-conversation",
      "name": "Update Conversation Summary",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        480,
        240
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ \"update public.conversations set summary = \" + $json.summary_sql + \", topics = \" + $json.topics_sql + \"::jsonb, mood = \" + $json.mood_sql + \", ended_at = coalesce(ended_at, now()), is_active = false where id = '\" + $json.conversation_id + \"';\" }}",
        "options": {}
      }
    },
    {
      "id": "wf4-close-empty",
      "name": "Close Empty Conversation",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -180,
        360
      ],
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ \"update public.conversations set ended_at = coalesce(ended_at, now()), is_active = false where id = '\" + $json.conversation_id + \"';\" }}",
        "options": {}
      }
    }
  ],
  "connections": {
    "Cron Every 10 Minutes": {
      "main": [
        [
          {
            "node": "Select Stale Conversations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Stale Conversations": {
      "main": [
        [
          {
            "node": "Load Conversation Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Conversation Context": {
      "main": [
        [
          {
            "node": "Build Transcript + Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Transcript + Prompt": {
      "main": [
        [
          {
            "node": "Has Messages?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Messages?": {
      "main": [
        [
          {
            "node": "Gemini Summarize",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Gemini + Payload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Close Empty Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini Summarize": {
      "main": [
        [
          {
            "node": "Merge Gemini + Payload",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Gemini + Payload": {
      "main": [
        [
          {
            "node": "Parse Summary JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Summary JSON": {
      "main": [
        [
          {
            "node": "Update Conversation Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "templateCredsSetupCompleted": false
  }
}
