<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#FAFAF7" />
  <title>MaiTribe</title>
  <meta name="description" content="Your holistic AI companion for body, mind and soul" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <link rel="icon" type="image/svg+xml" href="/icons/icon-512x512.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.svg" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="MaiTribe" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="apple-touch-startup-image" href="/icons/apple-touch-icon.svg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3)" />
  <link rel="apple-touch-startup-image" href="/icons/apple-touch-icon.svg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3)" />
  <link rel="apple-touch-startup-image" href="/icons/apple-touch-icon.svg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3)" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,300;1,9..40,400&family=DM+Serif+Display&display=swap" rel="stylesheet" />
  <style>
    :root {
      /* Sage & Earth */
      --sage-50: #F6F7F4;
      --sage-100: #ECEEE8;
      --sage-200: #DDE1D5;
      --sage-300: #C2C9B8;
      --sage-400: #A3AD96;
      --sage-500: #8A9678;
      --sage-600: #6B7A5E;
      --sage-700: #556349;
      --sage-800: #3D4A35;
      --sage-900: #2A3325;

      /* Neutrals */
      --cream: #FAFAF7;
      --cream-warm: #F5F3EE;
      --stone-100: #E8E6E1;
      --stone-200: #D4D1CA;
      --stone-400: #A09B92;
      --stone-600: #6B665D;

      /* Semantic */
      --text-primary: #2A2825;
      --text-secondary: #6B665D;
      --text-tertiary: #A09B92;
      --bg-primary: #FAFAF7;
      --bg-secondary: #F5F3EE;
      --bg-card: #FFFFFF;

      /* Chat */
      --bubble-mai: #F0F2EC;
      --bubble-user: #556349;
      --bubble-user-text: #FAFAF7;

      /* Check-in */
      --body-color: #C87A5E;
      --mind-color: #5E8AC8;
      --soul-color: #9B6BC8;
      --energy-color: #D4A843;

      /* Legacy compat */
      --sage: #8A9678;
      --gold: #D4A843;
      --warn: #C87A5E;
      --muted: #6B665D;
      --line: rgba(0,0,0,0.06);
      --card: #FFFFFF;
      --card-strong: #F5F3EE;
      --forest: #2A3325;

      /* Spacing */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-full: 9999px;
      --radius: 16px;
      --shadow: 0 1px 3px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.03);
      --ease: all 300ms ease;
    }

    * { box-sizing: border-box; margin: 0; }

    html, body {
      margin: 0;
      width: 100%;
      min-height: 100%;
      font-family: "DM Sans", sans-serif;
      font-weight: 400;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body::before { display: none; }

    ::-webkit-scrollbar { width: 0; height: 0; }

    .app {
      position: relative;
      width: 100%;
      min-height: 100dvh;
      max-width: 480px;
      margin: 0 auto;
      padding-bottom: calc(env(safe-area-inset-bottom) + 72px);
      z-index: 1;
    }

    .screen {
      position: absolute;
      inset: 0;
      display: none;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 300ms ease, transform 300ms ease;
      padding: 20px 16px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .screen.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }

    /* ── Typography ── */
    .screen-title {
      font-family: "DM Serif Display", serif;
      font-size: 24px;
      line-height: 1.2;
      margin: 0;
      font-weight: 400;
      color: var(--text-primary);
    }

    .muted { color: var(--text-secondary); line-height: 1.5; margin: 0; font-size: 14px; }
    .helper { font-size: 13px; color: var(--text-tertiary); margin: 0; line-height: 1.5; }
    .error { color: var(--warn); }
    .status { min-height: 20px; font-size: 13px; color: var(--sage-600); margin-top: 6px; }
    .hidden { display: none !important; }

    .stack { display: grid; gap: 14px; }
    .row { display: flex; align-items: center; gap: 10px; }
    .row.spread { justify-content: space-between; }

    /* ── Cards ── */
    .panel {
      padding: 20px;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(0,0,0,0.03);
      background: var(--bg-card);
      margin-top: 12px;
      box-shadow: var(--shadow);
    }

    .glass {
      background: var(--bg-card);
      border: 1px solid rgba(0,0,0,0.03);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
    }

    /* ── Forms ── */
    label { font-size: 14px; color: var(--text-secondary); display: block; margin-bottom: 6px; font-weight: 500; }
    input, select, textarea, button { font: inherit; color: inherit; }
    input, select, textarea {
      width: 100%;
      border: 1.5px solid var(--stone-200);
      background: var(--bg-card);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      padding: 12px 14px;
      font-size: 15px;
      transition: var(--ease);
    }
    textarea { min-height: 100px; resize: vertical; }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--sage-500);
      box-shadow: 0 0 0 3px rgba(85,99,73,0.12);
    }
    input::placeholder, textarea::placeholder { color: var(--text-tertiary); }

    button { border: none; border-radius: var(--radius-md); padding: 12px 16px; transition: var(--ease); cursor: pointer; font-weight: 500; }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    button:active { transform: scale(0.98); }

    .btn {
      background: var(--bg-secondary);
      border: 1px solid var(--stone-200);
      color: var(--text-primary);
    }
    .btn:hover { background: var(--stone-100); }

    .btn-primary {
      background: var(--sage-700);
      border: none;
      color: white;
      font-weight: 500;
    }
    .btn-primary:hover { background: var(--sage-800); }

    .btn-inline { padding: 8px 12px; font-size: 14px; background: transparent; border: none; color: var(--text-secondary); }
    .btn-inline:hover { color: var(--text-primary); }

    /* ── Splash ── */
    .logo {
      font-family: "DM Serif Display", serif;
      font-size: clamp(3rem, 10vw, 4.2rem);
      letter-spacing: 0.3px;
      margin: 0;
      font-weight: 400;
      line-height: 0.95;
    }
    .logo-mai { color: var(--sage-800); }
    .logo-tribe { color: var(--sage-500); font-style: italic; }
    .subtitle { margin-top: 0.75rem; color: var(--text-tertiary); letter-spacing: 0.12em; text-transform: lowercase; font-size: 13px; }
    .splash-wrap { height: 100%; display: flex; align-items: center; justify-content: center; text-align: center; animation: fadeIn 1s ease; }

    /* ── Auth ── */
    .auth-head { text-align: center; margin-bottom: 24px; }
    .tiny-logo { font-family: "DM Serif Display", serif; font-size: 2rem; margin: 0 0 0.5rem; font-weight: 400; }

    /* ── Onboarding ── */
    .onboard-step { display: none; }
    .onboard-step.active { display: block; }
    .onboard-progress { font-size: 12px; color: var(--text-tertiary); margin-bottom: 10px; letter-spacing: 0.08em; text-transform: uppercase; font-weight: 500; }
    .onboard-copy { line-height: 1.6; color: var(--text-primary); white-space: pre-line; font-size: 15px; }

    /* ── Home ── */
    .home-top { margin-bottom: 20px; padding-top: 8px; }
    .home-sub { font-size: 14px; color: var(--text-secondary); margin: 0 0 2px; font-weight: 400; }
    .greeting {
      font-family: "DM Serif Display", serif;
      font-size: 28px;
      margin: 0;
      font-weight: 400;
      color: var(--text-primary);
    }

    .home-card {
      background: var(--bg-card);
      border: 1px solid rgba(0,0,0,0.03);
      border-radius: var(--radius-lg);
      padding: 20px;
      margin-bottom: 12px;
      box-shadow: var(--shadow);
      transition: transform 200ms ease;
      animation: slideUp 400ms ease both;
    }
    .home-card:nth-child(2) { animation-delay: 60ms; }
    .home-card:nth-child(3) { animation-delay: 120ms; }
    .home-card:nth-child(4) { animation-delay: 180ms; }
    .home-card:hover { transform: translateY(-1px); }

    .home-card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 14px; }
    .home-card-icon {
      width: 40px; height: 40px; border-radius: var(--radius-md);
      display: grid; place-items: center; font-size: 18px; flex-shrink: 0;
    }
    .home-card-icon.sage { background: var(--sage-100); color: var(--sage-700); }
    .home-card-icon.gold { background: #FDF6E3; color: var(--energy-color); }
    .home-card-icon.purple { background: #F3EEFA; color: var(--soul-color); }
    .home-card-title { font-weight: 600; font-size: 15px; color: var(--text-primary); }
    .home-card-sub { font-size: 13px; color: var(--text-tertiary); margin-top: 1px; }

    .checkin-mini-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px;
    }
    .checkin-mini-item {
      display: flex; align-items: center; gap: 6px; font-size: 13px; color: var(--text-secondary);
    }
    .checkin-mini-item > span:first-child { min-width: 44px; }
    .checkin-mini-bar {
      flex: 1; height: 4px; border-radius: 2px; background: var(--stone-100); overflow: hidden;
    }
    .checkin-mini-fill { height: 100%; border-radius: 2px; transition: width 600ms ease; }

    .home-card-btn {
      width: 100%; padding: 10px; border-radius: var(--radius-md);
      background: var(--sage-700); color: white; font-weight: 500; font-size: 14px;
      border: none; cursor: pointer; transition: var(--ease);
    }
    .home-card-btn:hover { background: var(--sage-800); }

    .identity-card {
      padding: 0; border-radius: var(--radius-lg); border: 1px solid rgba(0,0,0,0.03);
      background: var(--bg-card); margin-bottom: 12px; cursor: pointer;
      transition: transform 200ms ease; box-shadow: var(--shadow);
    }
    .identity-card:hover { transform: translateY(-1px); }
    .identity-card-inner { padding: 20px; }
    .identity-quote {
      font-family: "DM Serif Display", serif;
      font-size: 16px; line-height: 1.5; margin: 0;
      color: var(--text-primary);
    }
    .identity-evidence { padding: 14px 20px; border-top: 1px solid rgba(0,0,0,0.04); font-size: 13px; color: var(--text-tertiary); }

    .insight-card {
      background: linear-gradient(135deg, #F6F7F4 0%, #F5F3EE 100%);
      border: 1px solid #DDE1D5; border-radius: var(--radius-lg);
      padding: 20px; box-shadow: var(--shadow);
    }
    .insight-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    .insight-avatar {
      width: 28px; height: 28px; border-radius: var(--radius-full);
      background: var(--sage-700); color: white; display: grid; place-items: center;
      font-family: "DM Serif Display", serif; font-size: 14px;
    }
    .insight-label { font-size: 13px; color: var(--sage-600); font-weight: 500; }
    .insight-text { font-size: 15px; line-height: 1.6; color: var(--text-primary); }

    .quick-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 14px; }
    .action-tile {
      padding: 16px; min-height: 80px; border: 1px solid rgba(0,0,0,0.03);
      border-radius: var(--radius-lg); background: var(--bg-card); display: grid;
      place-content: center; text-align: center; gap: 4px; font-weight: 500;
      font-size: 15px; color: var(--text-primary); box-shadow: var(--shadow);
      transition: transform 200ms ease;
    }
    .action-tile:hover { transform: translateY(-1px); }
    .action-tile small { color: var(--text-tertiary); font-weight: 400; font-size: 12px; }

    /* ── Chat ── */
    .chat-shell {
      display: grid; grid-template-rows: auto 1fr auto;
      height: calc(100dvh - 16px - env(safe-area-inset-bottom)); gap: 0;
    }
    .chat-header {
      display: flex; align-items: center; gap: 12px;
      padding: 12px 0 14px; border-bottom: 1px solid rgba(0,0,0,0.04);
    }
    .chat-avatar {
      width: 36px; height: 36px; border-radius: var(--radius-full);
      background: var(--sage-700); color: white; display: grid; place-items: center;
      font-family: "DM Serif Display", serif; font-size: 16px; flex-shrink: 0;
    }
    .chat-header-info { flex: 1; }
    .chat-header-name { font-weight: 600; font-size: 16px; color: var(--text-primary); }
    .chat-header-status { font-size: 12px; color: var(--sage-500); }
    .chat-header-btn {
      width: 36px; height: 36px; border-radius: var(--radius-full);
      background: var(--bg-secondary); border: 1px solid var(--stone-200);
      display: grid; place-items: center; font-size: 16px; color: var(--text-secondary);
      cursor: pointer; padding: 0;
    }
    .chat-header-btn:hover { background: var(--stone-100); }

    .chat-title { display: none; }

    .chat-area {
      border: none; border-radius: 0; background: transparent;
      padding: 16px 0; overflow-y: auto; display: grid; align-content: start; gap: 12px;
    }
    .chat-empty-state { color: var(--text-tertiary); text-align: center; margin-top: 30%; line-height: 1.6; font-size: 14px; }

    .bubble-wrap { display: flex; gap: 8px; align-items: flex-end; animation: msgIn 300ms ease both; }
    .bubble-wrap.user { justify-content: flex-end; }
    .bubble-avatar {
      width: 28px; height: 28px; border-radius: var(--radius-full);
      background: var(--sage-200); color: var(--sage-700); display: grid; place-items: center;
      font-family: "DM Serif Display", serif; font-size: 12px; flex-shrink: 0;
      align-self: flex-end;
    }

    .bubble {
      max-width: 78%; padding: 12px 16px; font-size: 15px; line-height: 1.55;
      white-space: pre-wrap; word-break: break-word;
    }
    .bubble.assistant {
      justify-self: start; background: var(--bubble-mai); color: var(--text-primary);
      border-radius: 18px 18px 18px 6px; border: none;
    }
    .bubble.user {
      justify-self: end; background: var(--bubble-user); color: var(--bubble-user-text);
      border-radius: 18px 18px 6px 18px; border: none;
    }

    .typing { display: inline-flex; gap: 5px; align-items: center; padding: 4px 0; }
    .typing i {
      width: 7px; height: 7px; border-radius: 50%; background: var(--sage-400);
      animation: bounce 1.2s infinite;
    }
    .typing i:nth-child(2) { animation-delay: 0.15s; }
    .typing i:nth-child(3) { animation-delay: 0.3s; }

    .chat-input-wrap {
      display: flex; align-items: flex-end; gap: 8px;
      padding: 12px 0 calc(env(safe-area-inset-bottom) + 80px);
    }
    .chat-input-container {
      flex: 1; display: flex; align-items: flex-end;
      border: 1.5px solid var(--stone-200); border-radius: var(--radius-xl);
      background: var(--bg-card); padding: 4px 14px; min-height: 44px;
      transition: var(--ease);
    }
    .chat-input-container:focus-within { border-color: var(--sage-500); }
    #chat-input {
      border: none; background: transparent; padding: 8px 0; min-height: 28px;
      font-size: 15px; resize: none; flex: 1; line-height: 1.4;
    }
    #chat-input:focus { box-shadow: none; }
    .chat-send-btn {
      width: 40px; height: 40px; border-radius: var(--radius-full);
      background: var(--sage-700); color: white; display: grid; place-items: center;
      font-size: 16px; border: none; cursor: pointer; flex-shrink: 0;
      transition: var(--ease);
    }
    .chat-send-btn:hover { background: var(--sage-800); }

    /* ── Check-in ── */
    .checkin-header { text-align: center; margin-bottom: 28px; padding-top: 12px; }
    .checkin-title { font-family: "DM Serif Display", serif; font-size: 24px; color: var(--text-primary); margin: 0; }
    .checkin-sub { font-size: 14px; color: var(--text-tertiary); margin: 6px 0 0; }

    .slider-wrap { margin-bottom: 20px; }
    .slider-row {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 8px;
    }
    .slider-label { font-size: 15px; color: var(--text-primary); font-weight: 500; }
    .slider-val {
      font-family: "DM Serif Display", serif; font-size: 24px; min-width: 32px;
      text-align: right; line-height: 1;
    }
    .slider-val.body { color: var(--body-color); }
    .slider-val.mind { color: var(--mind-color); }
    .slider-val.soul { color: var(--soul-color); }
    .slider-val.energy { color: var(--energy-color); }

    input[type="range"] {
      appearance: none; padding: 0; border: none; background: transparent;
      width: 100%; height: 28px;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px; background: var(--stone-100); border-radius: 3px;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 22px; height: 22px; margin-top: -8px;
      border-radius: 50%; border: 2px solid white; background: var(--sage-600);
      box-shadow: 0 2px 6px rgba(0,0,0,0.15); cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      height: 6px; background: var(--stone-100); border-radius: 3px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 22px; height: 22px; border-radius: 50%; border: 2px solid white;
      background: var(--sage-600); cursor: pointer;
    }
    input[type="range"].body-slider::-webkit-slider-thumb { background: var(--body-color); }
    input[type="range"].mind-slider::-webkit-slider-thumb { background: var(--mind-color); }
    input[type="range"].soul-slider::-webkit-slider-thumb { background: var(--soul-color); }
    input[type="range"].energy-slider::-webkit-slider-thumb { background: var(--energy-color); }
    input[type="range"].body-slider::-moz-range-thumb { background: var(--body-color); }
    input[type="range"].mind-slider::-moz-range-thumb { background: var(--mind-color); }
    input[type="range"].soul-slider::-moz-range-thumb { background: var(--soul-color); }
    input[type="range"].energy-slider::-moz-range-thumb { background: var(--energy-color); }

    .checkin-note-wrap { margin-top: 8px; }
    .checkin-note-wrap textarea { border-radius: var(--radius-lg); min-height: 80px; }
    .checkin-submit-btn {
      width: 100%; padding: 14px; border-radius: var(--radius-lg);
      background: var(--sage-700); color: white; font-weight: 500; font-size: 16px;
      border: none; cursor: pointer; margin-top: 20px; transition: var(--ease);
    }
    .checkin-submit-btn:hover { background: var(--sage-800); }

    /* ── Profile / Settings ── */
    .profile-header { text-align: center; padding: 20px 0; }
    .profile-avatar {
      width: 72px; height: 72px; border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--sage-300), var(--sage-500));
      display: grid; place-items: center; margin: 0 auto 12px;
      font-family: "DM Serif Display", serif; font-size: 28px; color: white;
    }
    .profile-name { font-family: "DM Serif Display", serif; font-size: 22px; color: var(--text-primary); }
    .profile-email { font-size: 13px; color: var(--text-tertiary); margin-top: 2px; }

    .profile-stats {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px;
      background: rgba(0,0,0,0.04); border-radius: var(--radius-lg); overflow: hidden;
      margin: 16px 0;
    }
    .profile-stat { background: var(--bg-card); padding: 16px 8px; text-align: center; }
    .profile-stat-num { font-family: "DM Serif Display", serif; font-size: 24px; color: var(--text-primary); }
    .profile-stat-label { font-size: 12px; color: var(--text-tertiary); margin-top: 2px; }

    .settings-group {
      background: var(--bg-card); border-radius: var(--radius-lg);
      border: 1px solid rgba(0,0,0,0.03); box-shadow: var(--shadow);
      margin-bottom: 12px; overflow: hidden;
    }
    .settings-group-title {
      font-weight: 600; font-size: 13px; color: var(--text-tertiary);
      text-transform: uppercase; letter-spacing: 0.05em;
      padding: 16px 20px 8px;
    }
    .settings-item {
      display: flex; align-items: center; gap: 14px;
      padding: 14px 20px; border-bottom: 1px solid rgba(0,0,0,0.03);
    }
    .settings-item:last-child { border-bottom: none; }
    .settings-item-icon {
      width: 32px; height: 32px; border-radius: var(--radius-sm);
      display: grid; place-items: center; font-size: 15px; flex-shrink: 0;
    }
    .settings-item-icon.sage { background: var(--sage-100); color: var(--sage-700); }
    .settings-item-icon.blue { background: #EBF0FA; color: var(--mind-color); }
    .settings-item-icon.gold { background: #FDF6E3; color: var(--energy-color); }
    .settings-item-icon.red { background: #FAEAEA; color: var(--warn); }
    .settings-item-content { flex: 1; }
    .settings-item-label { font-size: 15px; color: var(--text-primary); }
    .settings-item-desc { font-size: 12px; color: var(--text-tertiary); }
    .settings-item-chevron { color: var(--text-tertiary); font-size: 14px; }
    .settings-item.danger .settings-item-label { color: var(--warn); }

    .toggle { position: relative; width: 48px; height: 28px; display: inline-block; }
    .toggle input { opacity: 0; width: 0; height: 0; position: absolute; }
    .toggle span {
      position: absolute; inset: 0; border-radius: 999px;
      background: var(--stone-200); border: none; transition: var(--ease);
    }
    .toggle span::before {
      content: ""; position: absolute; width: 22px; height: 22px;
      left: 3px; top: 3px; border-radius: 50%; background: white;
      transition: var(--ease); box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    .toggle input:checked + span { background: var(--sage-600); }
    .toggle input:checked + span::before { transform: translateX(20px); }

    /* ── Identity ── */
    .identity-view {
      padding: 24px; border: 1px solid rgba(0,0,0,0.03); border-radius: var(--radius-lg);
      background: var(--bg-card); box-shadow: var(--shadow);
      font-family: "DM Serif Display", serif; font-size: 18px;
      line-height: 1.6; min-height: 200px; white-space: pre-wrap;
      color: var(--text-primary);
    }

    /* ── Bottom Navigation ── */
    .bottom-nav {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom) + 8px);
      width: min(92%, 400px); padding: 6px 20px;
      border-radius: var(--radius-full); background: white;
      border: 1px solid rgba(0,0,0,0.06);
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      display: none; grid-template-columns: 1fr 1fr 1fr;
      align-items: center; z-index: 20;
    }
    .bottom-nav button {
      background: transparent; border: none; color: var(--text-tertiary);
      padding: 8px 4px; font-size: 11px; display: flex; flex-direction: column;
      align-items: center; gap: 2px; position: relative;
    }
    .bottom-nav button.active { color: var(--sage-700); }
    .bottom-nav button.active .nav-ico { color: var(--sage-700); }
    .nav-ico { font-size: 20px; line-height: 1; }
    .nav-label { font-size: 11px; font-weight: 500; }

    .nav-chat-btn {
      display: flex !important; flex-direction: column !important; align-items: center !important;
      gap: 2px !important; padding: 0 !important; background: transparent !important;
      margin-top: -12px; position: relative;
    }
    .nav-chat-btn .nav-ico {
      width: 48px; height: 48px; border-radius: var(--radius-full);
      background: var(--sage-700); color: white;
      display: grid; place-items: center; font-size: 22px;
      box-shadow: 0 4px 12px rgba(85,99,73,0.3);
    }
    .nav-chat-btn .nav-label { display: block; font-size: 11px; color: var(--sage-700); font-weight: 500; margin-top: 2px; }
    .nav-chat-btn.active .nav-ico { background: var(--sage-800); }
    .nav-chat-btn.active .nav-label { color: var(--sage-800); }

    /* ── Dein Spiegel ── */
    .spiegel-back { display: flex; align-items: center; gap: 6px; margin-bottom: 16px; }
    .spiegel-back button { background: none; border: none; font-size: 22px; color: var(--text-secondary); cursor: pointer; padding: 4px; }
    .spiegel-header { text-align: center; margin-bottom: 20px; }
    .spiegel-header h2 { font-family: "DM Serif Display", serif; font-size: 22px; color: var(--text-primary); }
    .spiegel-header p { font-size: 13px; color: var(--text-secondary); margin-top: 4px; }
    .spiegel-birth-form { background: var(--bg-card); border-radius: var(--radius-lg); padding: 20px; box-shadow: var(--shadow); margin-bottom: 16px; }
    .spiegel-birth-form label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; margin-top: 12px; }
    .spiegel-birth-form label:first-child { margin-top: 0; }
    .spiegel-birth-form input { width: 100%; padding: 10px 12px; border: 1px solid var(--stone-100); border-radius: var(--radius-sm); font-size: 15px; font-family: inherit; background: var(--bg-primary); }
    .spiegel-birth-form .birth-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .spiegel-birth-form .btn-primary { margin-top: 16px; width: 100%; }
    .spiegel-birth-form .btn { margin-top: 8px; width: 100%; font-size: 13px; }

    .spiegel-card { background: var(--bg-card); border-radius: var(--radius-lg); padding: 18px; box-shadow: var(--shadow); margin-bottom: 14px; }
    .spiegel-card-title { font-family: "DM Serif Display", serif; font-size: 17px; color: var(--text-primary); margin-bottom: 10px; display: flex; align-items: center; gap: 8px; }
    .spiegel-card-icon { font-size: 20px; }
    .spiegel-row { display: flex; justify-content: space-between; align-items: baseline; padding: 6px 0; border-bottom: 1px solid var(--line); }
    .spiegel-row:last-child { border-bottom: none; }
    .spiegel-label { font-size: 13px; color: var(--text-secondary); }
    .spiegel-value { font-size: 14px; color: var(--text-primary); font-weight: 500; }
    .spiegel-desc { font-size: 13px; color: var(--text-secondary); line-height: 1.5; margin-top: 6px; }
    .spiegel-big-three { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 6px; }
    .spiegel-big-item { text-align: center; padding: 10px 4px; background: var(--sage-50); border-radius: var(--radius-md); }
    .spiegel-big-item .spiegel-big-icon { font-size: 20px; margin-bottom: 4px; }
    .spiegel-big-item .spiegel-big-sign { font-size: 14px; font-weight: 600; color: var(--text-primary); }
    .spiegel-big-item .spiegel-big-label { font-size: 11px; color: var(--text-secondary); margin-top: 2px; }

    .spiegel-hd-type { text-align: center; padding: 16px; background: linear-gradient(135deg, var(--sage-50), var(--cream-warm)); border-radius: var(--radius-md); margin-bottom: 10px; }
    .spiegel-hd-type-name { font-family: "DM Serif Display", serif; font-size: 20px; color: var(--sage-800); }
    .spiegel-hd-type-desc { font-size: 13px; color: var(--text-secondary); margin-top: 4px; }

    .spiegel-centers { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .spiegel-center-tag { padding: 4px 10px; border-radius: var(--radius-full); font-size: 12px; font-weight: 500; }
    .spiegel-center-tag.defined { background: var(--sage-200); color: var(--sage-800); }
    .spiegel-center-tag.undefined { background: var(--stone-100); color: var(--text-secondary); }

    .spiegel-share-btn { display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; padding: 12px; border: 1px solid var(--sage-300); border-radius: var(--radius-full); background: transparent; color: var(--sage-700); font-size: 14px; font-weight: 500; cursor: pointer; margin-top: 8px; font-family: inherit; }
    .spiegel-share-btn:active { background: var(--sage-50); }

    .spiegel-loading { text-align: center; padding: 40px 20px; }
    .spiegel-loading p { font-size: 14px; color: var(--text-secondary); margin-top: 12px; }

    .home-spiegel-card { background: linear-gradient(135deg, var(--sage-50), var(--cream-warm)); }
    .home-spiegel-preview { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
    .home-spiegel-item { text-align: center; font-size: 12px; color: var(--text-secondary); }
    .home-spiegel-item strong { display: block; font-size: 14px; color: var(--text-primary); }

    /* ── A2HS Banner ── */
    .a2hs-banner {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: var(--bg-card); border-top: 1px solid rgba(0,0,0,0.06);
      padding: 14px 18px; display: flex; align-items: center; gap: 12px;
      z-index: 100; transform: translateY(100%); transition: transform 0.4s ease;
    }
    .a2hs-banner.visible { transform: translateY(0); }
    .a2hs-banner .a2hs-text { flex: 1; font-size: 14px; color: var(--text-primary); }
    .a2hs-banner .a2hs-install { white-space: nowrap; }
    .a2hs-banner .a2hs-close { background: none; border: none; color: var(--text-tertiary); font-size: 1.2rem; cursor: pointer; padding: 4px; }

    /* ── Animations ── */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes pulse { 0%, 80%, 100% { opacity: 0.4; transform: translateY(0); } 40% { opacity: 1; transform: translateY(-2px); } }
    @keyframes bounce { 0%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-4px); } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes msgIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

    @media (min-width: 760px) {
      .app { padding-top: 10px; }
      .screen { padding: 24px 24px; }
    }
  </style>
</head>
<body>
  <main class="app">
    <section id="screen-splash" class="screen active">
      <div class="splash-wrap">
        <div>
          <h1 class="logo"><span class="logo-mai">mai</span><span class="logo-tribe">tribe</span></h1>
          <p id="splash-subtitle" class="subtitle">holistic · body · mind · soul</p>
        </div>
      </div>
    </section>

    <section id="screen-auth" class="screen">
      <div class="auth-head">
        <p class="tiny-logo"><span class="logo-mai">mai</span><span class="logo-tribe">tribe</span></p>
        <p id="auth-subtitle" class="muted">Your space. Your truth. Always private.</p>
      </div>

      <div class="panel stack">
        <div>
          <label id="auth-email-label" for="auth-email">Email</label>
          <input id="auth-email" type="email" placeholder="you@example.com" autocomplete="email" />
        </div>
        <button id="btn-magic-link" class="btn-primary" type="button">Continue with Email</button>
        <button id="btn-google" class="btn" type="button">Continue with Google</button>
        <p id="auth-status" class="status"></p>
      </div>

      <details class="panel" style="margin-top: 14px;">
        <summary id="auth-project-keys-summary" style="cursor: pointer; color: var(--muted);">Project keys</summary>
        <div class="stack" style="margin-top: 12px;">
          <div>
            <label for="cfg-supabase-url">SUPABASE_URL</label>
            <input id="cfg-supabase-url" type="url" placeholder="https://xxxx.supabase.co" />
          </div>
          <div>
            <label for="cfg-supabase-key">SUPABASE_ANON_KEY</label>
            <input id="cfg-supabase-key" type="text" placeholder="eyJ..." />
          </div>
          <div>
            <label for="cfg-gemini-key">GEMINI_API_KEY</label>
            <input id="cfg-gemini-key" type="text" placeholder="AIza..." />
          </div>
          <div>
            <label for="cfg-vapid-key">VAPID_PUBLIC_KEY (optional)</label>
            <input id="cfg-vapid-key" type="text" placeholder="BL..." />
          </div>
          <button id="btn-save-config" class="btn" type="button">Save keys</button>
          <p id="auth-keys-helper" class="helper">Keys are stored in localStorage for this device.</p>
          <p id="config-status" class="status"></p>
        </div>
      </details>
    </section>

    <section id="screen-onboarding" class="screen">
      <p id="onboard-progress" class="onboard-progress">Step 1 of 5</p>

      <div id="onboard-step-1" class="onboard-step active">
        <h2 id="onboard-welcome-title" class="screen-title">Welcome.</h2>
        <p id="onboard-welcome-text" class="onboard-copy">I am Mai - your companion for body, mind, and soul.

I am not a chatbot. I am not a coach. I am a quiet presence.

Let us start by getting to know each other.</p>
        <button id="btn-onboard-begin" class="btn-primary" type="button" style="margin-top: 10px;">Let's begin</button>
      </div>

      <div id="onboard-step-2" class="onboard-step">
        <h2 id="onboard-step2-title" class="screen-title">Tell me about you</h2>
        <div class="panel stack">
          <div>
            <label id="onboard-name-label" for="onboard-name">What should I call you?</label>
            <input id="onboard-name" type="text" autocomplete="name" />
          </div>
          <div>
            <label id="onboard-language-label" for="onboard-language">Language</label>
            <select id="onboard-language">
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="es">Espanol</option>
              <option value="fr">Francais</option>
              <option value="pt">Portugues</option>
              <option value="it">Italiano</option>
              <option value="nl">Nederlands</option>
            </select>
          </div>
          <div>
            <label id="onboard-timezone-label" for="onboard-timezone">Timezone</label>
            <input id="onboard-timezone" type="text" />
          </div>
          <button id="btn-onboard-step2" class="btn-primary" type="button">Continue</button>
        </div>
      </div>

      <div id="onboard-step-3" class="onboard-step">
        <h2 id="onboard-checkin-title" class="screen-title">How are you right now?</h2>
        <p id="onboard-checkin-sub" class="muted">Not how you think you should be. How you actually are.</p>
        <div class="panel" style="margin-top: 12px;">
          <div class="slider-wrap">
            <div class="slider-row"><span id="onboard-label-body">Body</span><strong id="onboard-body-val">5</strong></div>
            <input id="onboard-body" type="range" min="1" max="10" value="5" />
          </div>
          <div class="slider-wrap">
            <div class="slider-row"><span id="onboard-label-mind">Mind</span><strong id="onboard-mind-val">5</strong></div>
            <input id="onboard-mind" type="range" min="1" max="10" value="5" />
          </div>
          <div class="slider-wrap">
            <div class="slider-row"><span id="onboard-label-soul">Soul</span><strong id="onboard-soul-val">5</strong></div>
            <input id="onboard-soul" type="range" min="1" max="10" value="5" />
          </div>
          <div class="slider-wrap">
            <div class="slider-row"><span id="onboard-label-energy">Energy</span><strong id="onboard-energy-val">5</strong></div>
            <input id="onboard-energy" type="range" min="1" max="10" value="5" />
          </div>
          <label id="onboard-checkin-note-label" for="onboard-note">Anything on your mind? (optional)</label>
          <textarea id="onboard-note" placeholder="Share what feels true right now..."></textarea>
          <button id="btn-onboard-checkin" class="btn-primary" type="button">How does this feel today?</button>
          <p id="onboard-checkin-status" class="status"></p>
        </div>
        <div id="onboard-checkin-response" class="panel hidden" style="margin-top: 12px;"></div>
        <button id="btn-onboard-step3-next" class="btn" type="button" style="margin-top: 12px;">Continue</button>
      </div>

      <div id="onboard-step-4" class="onboard-step">
        <h2 id="onboard-identity-title" class="screen-title">Your Identity</h2>
        <p id="onboard-identity-sub" class="muted">I will ask you four short questions. There are no wrong answers.</p>

        <div class="panel stack" style="margin-top: 12px;">
          <p id="identity-question" class="onboard-copy"></p>
          <textarea id="identity-answer" placeholder="Write what feels true..."></textarea>
          <button id="btn-identity-next" class="btn-primary" type="button"></button>
          <p id="identity-status" class="status"></p>
        </div>

        <div id="identity-generated-wrap" class="panel hidden" style="margin-top: 12px;">
          <label id="onboard-identity-generated-label" for="identity-generated">Your generated identity (editable)</label>
          <textarea id="identity-generated"></textarea>
          <button id="btn-identity-accept" class="btn-primary" type="button">This feels right</button>
        </div>
      </div>

      <div id="onboard-step-5" class="onboard-step">
        <h2 id="onboard-reminders-title" class="screen-title">Gentle reminders</h2>
        <div class="panel stack">
          <div>
            <label id="onboard-wake-label" for="onboard-wake-time">When do you wake up?</label>
            <input id="onboard-wake-time" type="time" value="07:00" />
          </div>
          <div class="row spread">
            <div>
              <strong id="onboard-morning-label">Morning Identity reminder</strong>
              <p id="onboard-morning-help" class="helper">One calm reminder each morning.</p>
            </div>
            <label class="toggle"><input id="onboard-morning-toggle" type="checkbox" checked /><span></span></label>
          </div>
          <div class="row spread">
            <div>
              <strong id="onboard-mindful-label">Mindful reminders</strong>
              <p id="onboard-mindful-help" class="helper">Small grounding nudges during the day.</p>
            </div>
            <label class="toggle"><input id="onboard-mindful-toggle" type="checkbox" checked /><span></span></label>
          </div>
          <div>
            <label id="onboard-mindful-count-label" for="onboard-reminder-count">Mindful reminders per day</label>
            <select id="onboard-reminder-count">
              <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
          </select>
          </div>
          <button id="btn-request-notifications" class="btn" type="button">Enable notifications</button>
          <button id="btn-onboard-finish" class="btn-primary" type="button">I'm ready</button>
          <p id="onboard-finish-status" class="status"></p>
        </div>
      </div>
    </section>

    <section id="screen-home" class="screen">
      <div class="home-top">
        <p id="home-today-label" class="home-sub">Today</p>
        <h2 id="home-greeting" class="greeting">Welcome</h2>
      </div>

      <div id="btn-home-checkin" class="home-card" role="button" tabindex="0">
        <div class="home-card-header" style="justify-content:space-between;">
          <div style="display:flex;align-items:center;gap:12px;">
            <div class="home-card-icon sage">✦</div>
            <div class="home-card-title" id="home-checkin-title">Wie geht's dir?</div>
          </div>
          <span id="home-checkin-badge" style="font-size:12px;color:var(--sage-600);background:var(--sage-100);padding:3px 10px;border-radius:var(--radius-full);font-weight:500;">Heute</span>
        </div>
        <div id="home-checkin-mini" class="checkin-mini-grid">
          <div class="checkin-mini-item"><span id="home-mini-body">K&#246;rper</span><span id="home-mini-body-val" class="slider-val body" style="font-size:16px;min-width:20px;">0</span><div class="checkin-mini-bar"><div class="checkin-mini-fill" style="width:0%;background:var(--body-color)"></div></div></div>
          <div class="checkin-mini-item"><span id="home-mini-mind">Geist</span><span id="home-mini-mind-val" class="slider-val mind" style="font-size:16px;min-width:20px;">0</span><div class="checkin-mini-bar"><div class="checkin-mini-fill" style="width:0%;background:var(--mind-color)"></div></div></div>
          <div class="checkin-mini-item"><span id="home-mini-soul">Seele</span><span id="home-mini-soul-val" class="slider-val soul" style="font-size:16px;min-width:20px;">0</span><div class="checkin-mini-bar"><div class="checkin-mini-fill" style="width:0%;background:var(--soul-color)"></div></div></div>
          <div class="checkin-mini-item"><span id="home-mini-energy">Energie</span><span id="home-mini-energy-val" class="slider-val energy" style="font-size:16px;min-width:20px;">0</span><div class="checkin-mini-bar"><div class="checkin-mini-fill" style="width:0%;background:var(--energy-color)"></div></div></div>
        </div>
        <button id="home-checkin-btn" class="home-card-btn" type="button">Check-in starten</button>
      </div>

      <article id="home-identity-card" class="home-card" role="button" tabindex="0" aria-label="Open your identity">
        <div class="home-card-header">
          <div class="home-card-icon purple">◇</div>
          <div>
            <div class="home-card-title" id="home-identity-title">Deine Identit&#228;t</div>
            <div class="home-card-sub" id="home-identity-sub">Deine Wahrheit</div>
          </div>
        </div>
        <div class="identity-card-inner">
          <p id="home-identity-sentence" class="identity-quote">Deine Wahrheit erscheint hier nach dem Onboarding.</p>
        </div>
        <div id="home-identity-evidence" class="identity-evidence"></div>
      </article>

      <div class="insight-card home-card">
        <div class="insight-header">
          <div class="insight-avatar">m</div>
          <span class="insight-label" id="home-recent-label">Mai's Impuls</span>
        </div>
        <p id="home-recent-insight" class="insight-text">Noch keine Reflexionen.</p>
      </div>

      <div id="home-spiegel-card" class="home-card home-spiegel-card" role="button" tabindex="0" aria-label="Dein Spiegel">
        <div class="home-card-header">
          <div class="home-card-icon sage">&#9788;</div>
          <div>
            <div class="home-card-title" id="home-spiegel-title">Dein Spiegel</div>
            <div class="home-card-sub" id="home-spiegel-sub">Dein kosmisches Profil</div>
          </div>
        </div>
        <div id="home-spiegel-preview" class="home-spiegel-preview" style="display:none;">
          <div class="home-spiegel-item"><strong id="home-spiegel-sun">-</strong><span id="home-spiegel-sun-label">Sonne</span></div>
          <div class="home-spiegel-item"><strong id="home-spiegel-moon">-</strong><span id="home-spiegel-moon-label">Mond</span></div>
          <div class="home-spiegel-item"><strong id="home-spiegel-type">-</strong><span id="home-spiegel-type-label">HD Typ</span></div>
        </div>
        <p id="home-spiegel-cta" style="font-size:13px;color:var(--sage-600);margin-top:8px;">Entdecke dein kosmisches Profil &rarr;</p>
      </div>

      <button id="btn-home-chat" class="home-card" type="button" style="display:none;"></button>
    </section>

    <section id="screen-chat" class="screen">
      <div class="chat-shell">
        <header class="chat-header">
          <div class="chat-avatar">m</div>
          <div class="chat-header-info">
            <div class="chat-header-name">Mai</div>
            <div class="chat-header-status">online</div>
          </div>
          <button id="btn-chat-new" class="chat-header-btn" type="button" title="New chat">+</button>
        </header>

        <div id="chat-messages" class="chat-area"></div>

        <form id="chat-form" class="chat-input-wrap" autocomplete="off">
          <div class="chat-input-container">
            <input id="chat-input" type="text" placeholder="Schreib Mai..." />
          </div>
          <button id="btn-chat-send" class="chat-send-btn" type="submit" title="Send">↑</button>
        </form>
      </div>
    </section>

    <section id="screen-checkin" class="screen">
      <button id="btn-checkin-back" class="chat-header-btn" type="button" title="Back" style="margin-bottom:12px;">←</button>
      <div class="checkin-header">
        <h2 id="checkin-screen-title" class="checkin-title">How are you — really?</h2>
        <p class="checkin-sub">Not how you should be. How you actually are.</p>
      </div>

      <div class="panel">
        <div class="slider-wrap">
          <div class="slider-row"><span id="checkin-label-body" class="slider-label">Body</span><strong id="checkin-body-val" class="slider-val body">5</strong></div>
          <input id="checkin-body" class="body-slider" type="range" min="1" max="10" value="5" />
        </div>
        <div class="slider-wrap">
          <div class="slider-row"><span id="checkin-label-mind" class="slider-label">Mind</span><strong id="checkin-mind-val" class="slider-val mind">5</strong></div>
          <input id="checkin-mind" class="mind-slider" type="range" min="1" max="10" value="5" />
        </div>
        <div class="slider-wrap">
          <div class="slider-row"><span id="checkin-label-soul" class="slider-label">Soul</span><strong id="checkin-soul-val" class="slider-val soul">5</strong></div>
          <input id="checkin-soul" class="soul-slider" type="range" min="1" max="10" value="5" />
        </div>
        <div class="slider-wrap">
          <div class="slider-row"><span id="checkin-label-energy" class="slider-label">Energy</span><strong id="checkin-energy-val" class="slider-val energy">5</strong></div>
          <input id="checkin-energy" class="energy-slider" type="range" min="1" max="10" value="5" />
        </div>

        <div class="checkin-note-wrap">
          <label id="checkin-note-label" for="checkin-note">Anything on your mind? (optional)</label>
          <textarea id="checkin-note" placeholder="You can keep this short."></textarea>
        </div>

        <button id="btn-checkin-submit" class="checkin-submit-btn" type="button">Submit check-in</button>
        <p id="checkin-status" class="status"></p>
      </div>

      <div id="checkin-response" class="panel hidden" style="margin-top: 12px;"></div>
    </section>

    <section id="screen-identity" class="screen">
      <div class="row spread">
        <h2 id="identity-screen-title" class="screen-title">Your Identity</h2>
        <div class="row">
          <button id="btn-identity-back" class="btn btn-inline" type="button">Back</button>
          <button id="btn-identity-edit" class="btn btn-inline" type="button">Edit</button>
        </div>
      </div>

      <div id="identity-view" class="identity-view">No identity found yet.</div>

      <div id="identity-edit-wrap" class="panel hidden" style="margin-top: 12px;">
        <label id="identity-edit-label" for="identity-edit-text">Edit identity</label>
        <textarea id="identity-edit-text"></textarea>
        <div class="row" style="justify-content: flex-end; margin-top: 10px;">
          <button id="btn-identity-cancel" class="btn" type="button">Cancel</button>
          <button id="btn-identity-save" class="btn-primary" type="button">Save</button>
        </div>
        <p id="identity-edit-status" class="status"></p>
      </div>
    </section>

    <section id="screen-spiegel" class="screen">
      <div class="spiegel-back">
        <button id="btn-spiegel-back" type="button" title="Back">&larr;</button>
      </div>
      <div class="spiegel-header">
        <h2 id="spiegel-title">Dein Spiegel</h2>
        <p id="spiegel-sub">Dein kosmisches Profil</p>
      </div>

      <!-- Birth data form (shown when no birth data exists) -->
      <div id="spiegel-birth-form" class="spiegel-birth-form">
        <p id="spiegel-form-intro" style="font-size:14px;color:var(--text-secondary);margin-bottom:12px;line-height:1.5;">Um dein astrologisches Profil und Human Design zu berechnen, brauche ich deine Geburtsdaten.</p>
        <label id="spiegel-label-date" for="spiegel-birth-date">Geburtsdatum</label>
        <input id="spiegel-birth-date" type="date" />
        <div class="birth-row">
          <div>
            <label id="spiegel-label-time" for="spiegel-birth-time">Geburtszeit</label>
            <input id="spiegel-birth-time" type="time" value="12:00" />
          </div>
          <div>
            <label id="spiegel-label-timezone" for="spiegel-birth-tz">Zeitzone (UTC)</label>
            <input id="spiegel-birth-tz" type="number" min="-12" max="14" step="1" value="1" style="width:100%" />
          </div>
        </div>
        <label id="spiegel-label-place" for="spiegel-birth-place">Geburtsort</label>
        <input id="spiegel-birth-place" type="text" placeholder="z.B. Berlin, Deutschland" autocomplete="off" />
        <div id="spiegel-place-results" style="display:none;background:var(--bg-card);border:1px solid var(--stone-100);border-radius:var(--radius-sm);margin-top:4px;max-height:150px;overflow-y:auto;"></div>
        <button id="btn-spiegel-calculate" class="btn-primary" type="button">Berechnen</button>
        <button id="btn-spiegel-skip" class="btn" type="button">Sp&auml;ter</button>
        <p id="spiegel-form-status" class="status"></p>
      </div>

      <!-- Loading state -->
      <div id="spiegel-loading" class="spiegel-loading" style="display:none;">
        <div class="typing"><i></i><i></i><i></i></div>
        <p id="spiegel-loading-text">Berechne dein Profil...</p>
      </div>

      <!-- Results (shown when birth data exists) -->
      <div id="spiegel-results" style="display:none;">
        <!-- Big Three -->
        <div class="spiegel-card">
          <div class="spiegel-card-title"><span class="spiegel-card-icon">&#9788;</span> <span id="spiegel-astro-title">Dein Geburtschart</span></div>
          <div class="spiegel-big-three">
            <div class="spiegel-big-item">
              <div class="spiegel-big-icon">&#9788;</div>
              <div id="spiegel-sun" class="spiegel-big-sign">-</div>
              <div class="spiegel-big-label">Sonne</div>
            </div>
            <div class="spiegel-big-item">
              <div class="spiegel-big-icon">&#9789;</div>
              <div id="spiegel-moon" class="spiegel-big-sign">-</div>
              <div class="spiegel-big-label">Mond</div>
            </div>
            <div class="spiegel-big-item">
              <div class="spiegel-big-icon">&#8593;</div>
              <div id="spiegel-rising" class="spiegel-big-sign">-</div>
              <div class="spiegel-big-label">Aszendent</div>
            </div>
          </div>
          <div id="spiegel-planets-list"></div>
        </div>

        <!-- Human Design -->
        <div class="spiegel-card">
          <div class="spiegel-card-title"><span class="spiegel-card-icon">&#9672;</span> <span id="spiegel-hd-title">Human Design</span></div>
          <div class="spiegel-hd-type">
            <div id="spiegel-hd-type-name" class="spiegel-hd-type-name">-</div>
            <div id="spiegel-hd-type-desc" class="spiegel-hd-type-desc"></div>
          </div>
          <div id="spiegel-hd-details"></div>
          <div id="spiegel-hd-centers" class="spiegel-centers"></div>
        </div>

        <!-- Share -->
        <button id="btn-spiegel-share" class="spiegel-share-btn" type="button">
          <span>&#9741;</span> <span id="spiegel-share-label">Profil teilen</span>
        </button>

        <!-- Edit birth data -->
        <button id="btn-spiegel-edit" class="btn" type="button" style="width:100%;margin-top:8px;font-size:13px;">Geburtsdaten &auml;ndern</button>
      </div>
    </section>

    <section id="screen-settings" class="screen">
      <div class="profile-header">
        <div id="profile-avatar" class="profile-avatar">?</div>
        <div id="profile-display-name" class="profile-name"></div>
        <div id="profile-email" class="profile-email"></div>
      </div>

      <div id="profile-stats" class="profile-stats">
        <div class="profile-stat">
          <div id="stat-checkins" class="profile-stat-num">0</div>
          <div class="profile-stat-label">Check-ins</div>
        </div>
        <div class="profile-stat">
          <div id="stat-chats" class="profile-stat-num">0</div>
          <div class="profile-stat-label">Chats</div>
        </div>
        <div class="profile-stat">
          <div id="stat-days" class="profile-stat-num">0</div>
          <div class="profile-stat-label">Days</div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title" id="settings-profile-title">Profile</div>
        <div class="settings-item">
          <div class="settings-item-icon sage">👤</div>
          <div class="settings-item-content">
            <label id="settings-name-label" for="settings-name" style="margin:0">Name</label>
            <input id="settings-name" type="text" style="margin-top:4px" />
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon sage">🌐</div>
          <div class="settings-item-content">
            <label id="settings-language-label" for="settings-language" style="margin:0">Language</label>
            <select id="settings-language" style="margin-top:4px">
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="es">Espanol</option>
              <option value="fr">Francais</option>
              <option value="pt">Portugues</option>
              <option value="it">Italiano</option>
              <option value="nl">Nederlands</option>
            </select>
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon sage">🕐</div>
          <div class="settings-item-content">
            <label id="settings-timezone-label" for="settings-timezone" style="margin:0">Timezone</label>
            <input id="settings-timezone" type="text" style="margin-top:4px" />
          </div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title" id="settings-spiegel-title">Dein Spiegel</div>
        <div class="settings-item" role="button" tabindex="0" id="settings-spiegel-link" style="cursor:pointer;">
          <div class="settings-item-icon sage">&#9788;</div>
          <div class="settings-item-content">
            <span id="settings-spiegel-label" class="settings-item-label">Kosmisches Profil anzeigen</span>
            <span id="settings-birth-info" class="helper" style="font-size:12px;"></span>
          </div>
          <span style="color:var(--text-tertiary);font-size:16px;">&rarr;</span>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title" id="settings-reminders-title">Reminders</div>
        <div class="settings-item">
          <div class="settings-item-icon gold">⏰</div>
          <div class="settings-item-content">
            <label id="settings-morning-time-label" for="settings-morning-time" style="margin:0">Morning reminder time</label>
            <input id="settings-morning-time" type="time" value="07:00" style="margin-top:4px" />
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon gold">☀️</div>
          <div class="settings-item-content">
            <span id="settings-morning-enabled-label" class="settings-item-label">Morning reminder</span>
          </div>
          <label class="toggle"><input id="settings-morning-enabled" type="checkbox" /><span></span></label>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon gold">🧘</div>
          <div class="settings-item-content">
            <span id="settings-mindful-enabled-label" class="settings-item-label">Mindful reminders</span>
          </div>
          <label class="toggle"><input id="settings-mindful-enabled" type="checkbox" /><span></span></label>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon gold">🔢</div>
          <div class="settings-item-content">
            <label id="settings-mindful-count-label" for="settings-mindful-count" style="margin:0">Reminders per day</label>
            <select id="settings-mindful-count" style="margin-top:4px">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
            </select>
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon gold">📅</div>
          <div class="settings-item-content">
            <span id="settings-event-enabled-label" class="settings-item-label">Event follow-ups</span>
          </div>
          <label class="toggle"><input id="settings-event-enabled" type="checkbox" /><span></span></label>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title" id="settings-keys-title">API Keys</div>
        <div class="settings-item">
          <div class="settings-item-icon blue">🔑</div>
          <div class="settings-item-content">
            <label id="settings-gemini-label" for="settings-gemini" style="margin:0">Gemini API key</label>
            <input id="settings-gemini" type="text" placeholder="AIza..." style="margin-top:4px" />
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-item-icon blue">🔔</div>
          <div class="settings-item-content">
            <label id="settings-vapid-label" for="settings-vapid" style="margin:0">VAPID public key (optional)</label>
            <input id="settings-vapid" type="text" placeholder="BL..." style="margin-top:4px" />
          </div>
        </div>
      </div>

      <div style="padding: 0 4px; display: grid; gap: 8px; margin-top: 4px;">
        <button id="btn-settings-save" class="btn-primary" type="button">Save settings</button>
        <button id="btn-settings-push" class="btn" type="button">Register push notifications</button>
        <button id="btn-settings-test-push" class="btn" type="button">Test notification</button>
        <p id="settings-status" class="status"></p>
      </div>

      <div class="settings-group" style="margin-top: 12px;">
        <div class="settings-item danger" role="button" tabindex="0">
          <div class="settings-item-icon red">↪</div>
          <div class="settings-item-content">
            <button id="btn-logout" style="background:none;border:none;padding:0;font-size:15px;color:var(--warn);font-weight:500;cursor:pointer;">Logout</button>
          </div>
        </div>
      </div>

      <div style="text-align:center;padding:12px 0 20px;">
        <a id="settings-privacy-link" class="helper" href="/privacy.html" target="_blank" rel="noopener noreferrer">Privacy Policy</a>
      </div>
    </section>

    <nav id="bottom-nav" class="bottom-nav" aria-label="Main navigation">
      <button data-target="screen-home" class="active" type="button"><span class="nav-ico">⌂</span><span id="nav-home-label" class="nav-label">Home</span></button>
      <button data-target="screen-chat" class="nav-chat-btn" type="button"><span class="nav-ico">◎</span><span id="nav-chat-label" class="nav-label">Mai</span></button>
      <button data-target="screen-settings" type="button"><span class="nav-ico">◒</span><span id="nav-profile-label" class="nav-label">Profile</span></button>
    </nav>
  </main>

  <div id="a2hs-banner" class="a2hs-banner" role="alert">
    <span class="a2hs-text" id="a2hs-text">Install MaiTribe for the best experience</span>
    <button id="a2hs-install" class="btn-primary a2hs-install" type="button">Install</button>
    <button id="a2hs-close" class="a2hs-close" type="button" aria-label="Close">&times;</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.1"></script>
  <script>
    // Apply LockManager bypass immediately after Supabase SDK load.
    (function () {
      if (window.__maitribeLockBypassApplied) return;
      window.__maitribeLockBypassApplied = true;

      if (!navigator.locks) return;

      navigator.locks.request = async function (name, optionsOrCallback, maybeCallback) {
        const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
        if (callback) return callback();
      };
    })();
  </script>
  <script>
    (function () {
      const screens = [
        "screen-splash",
        "screen-auth",
        "screen-onboarding",
        "screen-home",
        "screen-chat",
        "screen-checkin",
        "screen-identity",
        "screen-spiegel",
        "screen-settings"
      ];

      const languageMap = {
        en: "English",
        de: "German",
        es: "Spanish",
        fr: "French",
        pt: "Portuguese",
        it: "Italian",
        nl: "Dutch"
      };

      const i18n = {
        en: {
          auth_subtitle: "Your space. Your truth. Always private.",
          auth_continue_email: "Continue with Email",
          auth_continue_google: "Continue with Google",
          onboard_welcome_title: "Welcome.",
          onboard_welcome_text: "I am Mai \u2014 your companion for body, mind, and soul.\n\nI am not a chatbot. I am not a coach. I am not an app that tells you what to do.\n\nI am a quiet presence. I listen. I remember. I walk next to you.\n\nLet's start by getting to know each other.",
          onboard_begin: "Let's begin",
          onboard_name_label: "What should I call you?",
          onboard_language_label: "Language",
          onboard_timezone_label: "Timezone",
          onboard_continue: "Continue",
          onboard_checkin_title: "How are you right now?",
          onboard_checkin_sub: "Not how you think you should be. How you actually are.",
          onboard_checkin_note_label: "Anything on your mind? (optional)",
          onboard_checkin_note_placeholder: "Share what feels true right now...",
          onboard_checkin_btn: "How does this feel today?",
          onboard_identity_title: "Your Identity",
          onboard_identity_sub: "I'll ask you four short questions. There are no wrong answers.",
          onboard_identity_placeholder: "Write what feels true...",
          onboard_identity_save_answer: "Save answer",
          onboard_identity_generate: "Generate identity",
          onboard_identity_generated_label: "Your generated identity (editable)",
          onboard_reminders_title: "Gentle reminders",
          onboard_wake_label: "When do you wake up?",
          onboard_morning_label: "Morning Identity reminder",
          onboard_morning_help: "One calm reminder each morning.",
          onboard_mindful_label: "Mindful reminders",
          onboard_mindful_help: "Small grounding nudges during the day.",
          onboard_mindful_count_label: "Mindful reminders per day",
          onboard_notify: "Enable notifications",
          onboard_ready: "I'm ready",
          identity_q1: "Imagine you wake up tomorrow living your absolute dream life. Where are you? What are you doing? How does your body feel? Describe it as concretely as you can.",
          identity_q2: "What matters most to you in life? Not what should matter \u2014 what truly does, deep down.",
          identity_q3: "What feeling do you want more of in your daily life? Not what you want to do \u2014 how you want to feel.",
          identity_q4: "Is there a dream you carry inside that you rarely say out loud? One that feels almost too big?",
          identity_save_answer: "Save & Next",
          identity_generate: "Generate my Identity",
          identity_accept: "This feels right",
          identity_generating: "Generating your identity...",
          identity_skip: "Skip \u2014 I\u2019ll edit later",
          identity_timeout_msg: "It\u2019s taking longer than expected. You can skip and edit your identity later.",
          home_today: "Today",
          home_identity_label: "Your Identity",
          home_identity_sub: "Your truth",
          home_checkin: "Check-in",
          home_checkin_title: "How are you?",
          home_checkin_btn: "Start check-in",
          home_checkin_sub: "Body \u00B7 Mind \u00B7 Soul",
          home_checkin_badge: "Today",
          home_chat: "Talk to Mai",
          home_chat_sub: "Quiet support",
          home_recent: "Mai's Insight",
          home_no_insight: "No reflections yet.",
          home_identity_placeholder: "Your truth will appear here once onboarding is complete.",
          home_mini_body: "Body",
          home_mini_mind: "Mind",
          home_mini_soul: "Soul",
          home_mini_energy: "Energy",
          chat_input_placeholder: "Write Mai...",
          profile_stat_checkins: "Check-ins",
          profile_stat_chats: "Chats",
          profile_stat_days: "Days",
          nav_mai: "Mai",
          greeting_night: "Still up, {name}?",
          greeting_morning: "Good morning, {name}",
          greeting_afternoon: "Good afternoon, {name}",
          greeting_evening: "Good evening, {name}",
          greeting_late: "Good night, {name}",
          chat_placeholder: "Share what's on your mind...",
          chat_back: "Back",
          chat_refresh: "Refresh",
          chat_mic: "Mic",
          chat_send: "Send",
          chat_mai_resting: "Mai is resting for a moment. Try again in a minute. \uD83C\uDF3F",
          chat_no_key: "Please add your Gemini API key in Settings.",
          chat_fallback_opening: "Hey. I am here. What feels most present right now?",
          chat_empty: "\uD83C\uDF3F\nMai is loading...\nPlease give it a moment.",
          checkin_title: "How are you \u2014 really?",
          checkin_back: "Back",
          checkin_note_label: "Anything on your mind? (optional)",
          checkin_note_placeholder: "You can keep this short.",
          checkin_submit: "Submit check-in",
          checkin_saving: "Saving...",
          checkin_saved: "Saved.",
          identity_title: "Your Identity",
          identity_back: "Back",
          identity_edit: "Edit",
          identity_cancel: "Cancel",
          identity_save: "Save",
          identity_empty: "No identity found yet.",
          identity_edit_label: "Edit identity",
          settings_title: "Settings",
          settings_logout: "Logout",
          settings_profile: "Profile",
          settings_name_label: "Name",
          settings_language_label: "Language",
          settings_timezone_label: "Timezone",
          settings_reminders: "Reminders",
          settings_morning_time: "Morning reminder time",
          settings_morning_enabled: "Morning reminder enabled",
          settings_mindful_enabled: "Mindful reminders enabled",
          settings_mindful_count: "Mindful reminders per day",
          settings_event_enabled: "Event follow-up reminders",
          settings_keys: "Project keys",
          settings_save: "Save settings",
          settings_push: "Register push notifications",
          settings_test_push: "Test notification",
          settings_privacy_link: "Read privacy policy",
          status_test_push_sent: "Test notification sent.",
          status_test_push_failed: "Could not send test notification. Register push first.",
          status_push_permission_denied: "Notification permission was denied. Please allow notifications in your browser settings.",
          settings_saved: "Saved.",
          nav_home: "Home",
          nav_chat: "Chat",
          nav_profile: "Profile",
          slider_body: "Body",
          slider_mind: "Mind",
          slider_soul: "Soul",
          slider_energy: "Energy",
          err_no_key: "Please add your Gemini API key in Settings.",
          err_api: "I am here. Let us try again in a moment.",
          err_timeout: "Mai can't respond right now. Please try again later.",
          err_rate_limit: "Mai needs a moment. Try again in a minute.",
          err_invalid_key: "Your API Key is invalid. Please check it in Settings.",
          status_api_key_validating: "Validating API key...",
          status_api_key_valid: "API Key is valid and saved.",
          status_api_key_invalid: "This API Key is invalid. Check it at aistudio.google.com/apikey",
          status_api_key_rate_limited: "Key saved, but currently rate-limited. Try again in a minute.",
          splash_subtitle: "holistic \u00B7 body \u00B7 mind \u00B7 soul",
          auth_email_label: "Email",
          auth_project_keys: "Project keys",
          auth_save_keys: "Save keys",
          auth_keys_helper: "Keys are stored in localStorage for this device.",
          onboard_step2_title: "Tell me about you",
          onboard_step_progress: "Step {step} of 5",
          home_identity_placeholder: "Your truth will appear here once onboarding is complete.",
          settings_gemini_label: "Gemini API key",
          settings_vapid_label: "VAPID public key (optional)",
          status_sending_magic: "Sending magic link...",
          status_check_inbox: "Check your inbox for the login link.",
          status_enter_email: "Enter your email.",
          status_configure_supabase: "Configure Supabase first.",
          status_email_rate_limit: "Too many login attempts. Please wait 5 minutes and try again.",
          status_could_not_load_profile: "Could not load your profile.",
          status_saved: "Saved.",
          status_saved_locally: "Saved locally.",
          status_reflecting: "Reflecting...",
          status_saving_checkin: "Saving check-in...",
          status_could_not_save_checkin: "Could not save your check-in.",
          status_reflection_ready: "Reflection ready.",
          status_checkin_ai_unavailable: "Mai couldn\u2019t reflect right now, but your check-in is saved. You can always come back.",
          status_identity_empty: "Identity cannot be empty.",
          status_could_not_save_identity: "Could not save identity.",
          status_identity_saved: "Identity saved.",
          status_push_not_supported: "Push notifications are not supported on this browser.",
          status_add_vapid: "Add VAPID public key in settings first.",
          status_push_enabled: "Push notifications enabled.",
          status_voice_not_supported: "Voice input is not supported in this browser.",
          status_could_not_capture_voice: "Could not capture voice input.",
          status_add_name: "Please add your name.",
          status_generate_identity: "Please generate or write your identity first.",
          status_saved_continue: "Saved. You can continue with login.",
          status_missing_supabase: "Missing Supabase values.",
          status_google_failed: "Google sign-in failed.",
          status_add_answer: "Please add an answer before continuing.",
          status_identity_text_empty: "Identity text cannot be empty.",
          status_generating_identity: "Generating your identity...",
          status_review_identity: "Review and edit your identity before saving.",
          status_fallback_generated: "Fallback text was generated.",
          status_could_not_save_settings: "Could not save settings.",
          status_could_not_send_magic: "Could not send magic link.",
          status_magic_expired: "Magic link expired or already used. Please request a new one.",
          status_share_name: "Please share your name first.",
          status_add_supabase: "Add your Supabase URL and anon key to continue.",
          status_supabase_sdk_fail: "Supabase SDK could not be loaded. Please reload the page.",
          status_start_failed: "Start failed. Please reload the page.",
          status_app_start_fail: "App did not start cleanly. Please reload the page.",
          status_local_mode: "Continuing in local mode.",
          a2hs_text: "Install MaiTribe for the best experience",
          a2hs_install: "Install",
          spiegel_title: "Your Mirror",
          spiegel_sub: "Your cosmic profile",
          spiegel_form_intro: "To calculate your astrological profile and Human Design, I need your birth data.",
          spiegel_label_date: "Birth date",
          spiegel_label_time: "Birth time",
          spiegel_label_timezone: "Timezone (UTC)",
          spiegel_label_place: "Birth place",
          spiegel_calculate: "Calculate",
          spiegel_skip: "Later",
          spiegel_loading: "Calculating your profile...",
          spiegel_astro_title: "Your Birth Chart",
          spiegel_hd_title: "Human Design",
          spiegel_share: "Share profile",
          spiegel_edit_birth: "Edit birth data",
          spiegel_sun: "Sun",
          spiegel_moon: "Moon",
          spiegel_rising: "Rising",
          spiegel_hd_strategy: "Strategy",
          spiegel_hd_authority: "Authority",
          spiegel_hd_profile: "Profile",
          spiegel_hd_definition: "Definition",
          spiegel_hd_cross: "Incarnation Cross",
          spiegel_hd_defined: "Defined",
          spiegel_hd_undefined: "Open",
          spiegel_home_title: "Your Mirror",
          spiegel_home_sub: "Your cosmic profile",
          spiegel_home_cta: "Discover your cosmic profile \u2192",
          spiegel_home_hd_type: "HD Type",
          spiegel_birth_saved: "Birth data saved!",
          spiegel_enter_date: "Please enter your birth date.",
          spiegel_enter_place: "Please enter your birth place.",
          spiegel_calc_error: "Calculation error. Please try again.",
          spiegel_place_placeholder: "e.g. Berlin, Germany",
          settings_spiegel_title: "Your Mirror",
          settings_spiegel_label: "View cosmic profile",
          settings_birth_not_set: "Not set up yet"
        },
        de: {
          onboard_welcome_title: "Willkommen.",
          onboard_welcome_text: "Ich bin Mai \u2014 deine Begleiterin f\u00FCr K\u00F6rper, Geist und Seele.\n\nIch bin kein Chatbot. Kein Coach. Keine App, die dir sagt, was du tun sollst.\n\nIch bin eine stille Pr\u00E4senz. Ich h\u00F6re zu. Ich erinnere mich. Ich gehe neben dir.\n\nLass uns damit anfangen, uns kennenzulernen.",
          onboard_begin: "Los geht\u2019s",
          onboard_name_label: "Wie soll ich dich nennen?",
          onboard_language_label: "Sprache",
          onboard_timezone_label: "Zeitzone",
          onboard_continue: "Weiter",
          onboard_checkin_title: "Wie geht es dir gerade?",
          onboard_checkin_sub: "Nicht wie du denkst, dass es dir gehen sollte. Wie es dir wirklich geht.",
          onboard_checkin_note_label: "Was bewegt dich gerade? (optional)",
          onboard_checkin_note_placeholder: "Teile, was sich gerade wahr anf\u00FChlt...",
          onboard_checkin_btn: "Wie f\u00FChlt sich das heute an?",
          onboard_identity_title: "Deine Identit\u00E4t",
          onboard_identity_sub: "Ich stelle dir vier kurze Fragen. Es gibt keine falschen Antworten.",
          onboard_identity_placeholder: "Schreib, was sich wahr anf\u00FChlt...",
          onboard_identity_save_answer: "Antwort speichern",
          onboard_identity_generate: "Identit\u00E4t erstellen",
          onboard_identity_generated_label: "Deine erstellte Identit\u00E4t (du kannst sie bearbeiten)",
          onboard_reminders_title: "Sanfte Erinnerungen",
          onboard_wake_label: "Wann wachst du auf?",
          onboard_morning_label: "Morgen-Identit\u00E4ts-Erinnerung",
          onboard_morning_help: "Eine ruhige Erinnerung jeden Morgen.",
          onboard_mindful_label: "Achtsame Erinnerungen",
          onboard_mindful_help: "Kleine erdende Impulse durch den Tag.",
          onboard_mindful_count_label: "Achtsame Erinnerungen pro Tag",
          onboard_notify: "Benachrichtigungen aktivieren",
          onboard_ready: "Ich bin bereit",
          identity_q1: "Stell dir vor, du wachst morgen auf und lebst dein absolutes Traumleben. Wo bist du? Was tust du? Wie f\u00FChlt sich dein K\u00F6rper an? Beschreib es so konkret wie m\u00F6glich.",
          identity_q2: "Was ist dir im Leben am wichtigsten? Nicht was wichtig sein sollte \u2014 was es wirklich ist, tief in dir drin.",
          identity_q3: "Welches Gef\u00FChl w\u00FCnschst du dir mehr in deinem Alltag? Nicht was du tun willst \u2014 wie du dich f\u00FChlen willst.",
          identity_q4: "Gibt es einen Traum, den du in dir tr\u00E4gst, den du selten laut aussprichst? Einen, der sich fast zu gro\u00DF anf\u00FChlt?",
          identity_save_answer: "Speichern & Weiter",
          identity_generate: "Meine Identit\u00E4t erstellen",
          identity_accept: "Das f\u00FChlt sich richtig an",
          identity_generating: "Deine Identit\u00E4t wird erstellt...",
          identity_skip: "\u00DCberspringen \u2014 ich bearbeite sp\u00E4ter",
          identity_timeout_msg: "Es dauert l\u00E4nger als erwartet. Du kannst \u00FCberspringen und deine Identit\u00E4t sp\u00E4ter bearbeiten.",
          home_today: "Heute",
          home_identity_label: "Deine Identit\u00E4t",
          home_identity_sub: "Deine Wahrheit",
          home_checkin: "Check-in",
          home_checkin_title: "Wie geht's dir?",
          home_checkin_btn: "Check-in starten",
          home_checkin_sub: "K\u00F6rper \u00B7 Geist \u00B7 Seele",
          home_checkin_badge: "Heute",
          home_chat: "Mit Mai sprechen",
          home_chat_sub: "Stille Begleitung",
          home_recent: "Mai's Impuls",
          home_no_insight: "Noch keine Reflexionen.",
          home_identity_placeholder: "Deine Wahrheit erscheint hier nach dem Onboarding.",
          home_mini_body: "K\u00F6rper",
          home_mini_mind: "Geist",
          home_mini_soul: "Seele",
          home_mini_energy: "Energie",
          chat_input_placeholder: "Schreib Mai...",
          profile_stat_checkins: "Check-ins",
          profile_stat_chats: "Gespr\u00E4che",
          profile_stat_days: "Tage",
          nav_mai: "Mai",
          greeting_night: "Noch wach, {name}?",
          greeting_morning: "Guten Morgen, {name}",
          greeting_afternoon: "Guten Nachmittag, {name}",
          greeting_evening: "Guten Abend, {name}",
          greeting_late: "Gute Nacht, {name}",
          chat_placeholder: "Teile, was dich bewegt...",
          chat_back: "Zur\u00FCck",
          chat_refresh: "Neu laden",
          chat_mic: "Mikro",
          chat_send: "Senden",
          chat_mai_resting: "Mai ruht sich gerade kurz aus. Versuch es in einer Minute noch einmal. \uD83C\uDF3F",
          chat_no_key: "Bitte trage deinen Gemini API Key in den Einstellungen ein.",
          chat_fallback_opening: "Hey. Ich bin da. Was bewegt dich gerade am meisten?",
          chat_empty: "\uD83C\uDF3F\nMai l\u00E4dt...\nEinen Moment noch.",
          checkin_title: "Wie geht es dir \u2014 wirklich?",
          checkin_back: "Zur\u00FCck",
          checkin_note_label: "Was bewegt dich gerade? (optional)",
          checkin_note_placeholder: "Du kannst es kurz halten.",
          checkin_submit: "Check-in abschicken",
          checkin_saving: "Speichere...",
          checkin_saved: "Gespeichert.",
          identity_title: "Deine Identit\u00E4t",
          identity_back: "Zur\u00FCck",
          identity_edit: "Bearbeiten",
          identity_cancel: "Abbrechen",
          identity_save: "Speichern",
          identity_empty: "Noch keine Identit\u00E4t erstellt.",
          identity_edit_label: "Identit\u00E4t bearbeiten",
          settings_title: "Einstellungen",
          settings_logout: "Abmelden",
          settings_profile: "Profil",
          settings_name_label: "Name",
          settings_language_label: "Sprache",
          settings_timezone_label: "Zeitzone",
          settings_reminders: "Erinnerungen",
          settings_morning_time: "Zeit der Morgen-Erinnerung",
          settings_morning_enabled: "Morgen-Erinnerung aktiv",
          settings_mindful_enabled: "Achtsame Erinnerungen aktiv",
          settings_mindful_count: "Achtsame Erinnerungen pro Tag",
          settings_event_enabled: "Event-Nachfragen aktiv",
          settings_keys: "Projekt-Schl\u00FCssel",
          settings_save: "Einstellungen speichern",
          settings_push: "Push-Benachrichtigungen aktivieren",
          settings_test_push: "Test-Benachrichtigung",
          settings_privacy_link: "Datenschutz lesen",
          status_test_push_sent: "Test-Benachrichtigung gesendet.",
          status_test_push_failed: "Konnte keine Test-Benachrichtigung senden. Bitte zuerst Push registrieren.",
          status_push_permission_denied: "Benachrichtigungen wurden abgelehnt. Bitte erlaube Benachrichtigungen in den Browser-Einstellungen.",
          settings_saved: "Gespeichert.",
          nav_home: "Home",
          nav_chat: "Chat",
          nav_profile: "Profil",
          slider_body: "K\u00F6rper",
          slider_mind: "Geist",
          slider_soul: "Seele",
          slider_energy: "Energie",
          err_no_key: "Bitte trage deinen Gemini API Key in den Einstellungen ein.",
          err_api: "Ich bin hier. Lass es uns in einem Moment noch einmal versuchen.",
          err_timeout: "Mai kann gerade nicht antworten. Bitte versuche es sp\u00E4ter.",
          err_rate_limit: "Mai braucht einen Moment. Versuch es in einer Minute nochmal.",
          err_invalid_key: "Dein API Key ist ung\u00FCltig. Bitte \u00FCberpr\u00FCfe ihn in den Einstellungen.",
          status_api_key_validating: "API Key wird \u00FCberpr\u00FCft...",
          status_api_key_valid: "API Key ist g\u00FCltig und gespeichert.",
          status_api_key_invalid: "Dieser API Key ist ung\u00FCltig. Pr\u00FCfe ihn auf aistudio.google.com/apikey",
          status_api_key_rate_limited: "Key gespeichert, aber gerade rate-limited. Versuch es in einer Minute.",
          auth_subtitle: "Dein Raum. Deine Wahrheit. Immer privat.",
          auth_continue_email: "Weiter mit E-Mail",
          auth_continue_google: "Weiter mit Google",
          splash_subtitle: "ganzheitlich \u00B7 K\u00F6rper \u00B7 Geist \u00B7 Seele",
          auth_email_label: "E-Mail",
          auth_project_keys: "Projekt-Schl\u00FCssel",
          auth_save_keys: "Schl\u00FCssel speichern",
          auth_keys_helper: "Schl\u00FCssel werden im localStorage dieses Ger\u00E4ts gespeichert.",
          onboard_step2_title: "Erz\u00E4hl mir von dir",
          onboard_step_progress: "Schritt {step} von 5",
          home_identity_placeholder: "Deine Wahrheit erscheint hier, sobald das Onboarding abgeschlossen ist.",
          settings_gemini_label: "Gemini API-Schl\u00FCssel",
          settings_vapid_label: "VAPID Public Key (optional)",
          status_sending_magic: "Magic Link wird gesendet...",
          status_check_inbox: "Pr\u00FCfe dein Postfach f\u00FCr den Login-Link.",
          status_enter_email: "Bitte gib deine E-Mail ein.",
          status_configure_supabase: "Bitte zuerst Supabase konfigurieren.",
          status_email_rate_limit: "Zu viele Login-Versuche. Bitte warte 5 Minuten und versuche es erneut.",
          status_could_not_load_profile: "Profil konnte nicht geladen werden.",
          status_saved: "Gespeichert.",
          status_saved_locally: "Lokal gespeichert.",
          status_reflecting: "Reflektiere...",
          status_saving_checkin: "Check-in wird gespeichert...",
          status_could_not_save_checkin: "Check-in konnte nicht gespeichert werden.",
          status_reflection_ready: "Reflexion bereit.",
          status_checkin_ai_unavailable: "Mai konnte gerade nicht reflektieren, aber dein Check-in ist gespeichert. Du kannst jederzeit zur\u00FCckkommen.",
          status_identity_empty: "Identit\u00E4t darf nicht leer sein.",
          status_could_not_save_identity: "Identit\u00E4t konnte nicht gespeichert werden.",
          status_identity_saved: "Identit\u00E4t gespeichert.",
          status_push_not_supported: "Push-Benachrichtigungen werden in diesem Browser nicht unterst\u00FCtzt.",
          status_add_vapid: "VAPID Public Key in den Einstellungen hinzuf\u00FCgen.",
          status_push_enabled: "Push-Benachrichtigungen aktiviert.",
          status_voice_not_supported: "Spracheingabe wird in diesem Browser nicht unterst\u00FCtzt.",
          status_could_not_capture_voice: "Spracheingabe konnte nicht erfasst werden.",
          status_add_name: "Bitte gib deinen Namen ein.",
          status_generate_identity: "Bitte erstelle oder schreibe zuerst deine Identit\u00E4t.",
          status_saved_continue: "Gespeichert. Du kannst dich jetzt anmelden.",
          status_missing_supabase: "Supabase-Werte fehlen.",
          status_google_failed: "Google-Anmeldung fehlgeschlagen.",
          status_add_answer: "Bitte gib eine Antwort ein, bevor du fortf\u00E4hrst.",
          status_identity_text_empty: "Identit\u00E4tstext darf nicht leer sein.",
          status_generating_identity: "Deine Identit\u00E4t wird erstellt...",
          status_review_identity: "Pr\u00FCfe deine Identit\u00E4t und passe sie an, wenn du m\u00F6chtest.",
          status_fallback_generated: "Fallback-Text wurde erstellt.",
          status_could_not_save_settings: "Einstellungen konnten nicht gespeichert werden.",
          status_could_not_send_magic: "Magic Link konnte nicht gesendet werden.",
          status_magic_expired: "Magic Link ist abgelaufen oder bereits genutzt. Bitte neuen Link anfordern.",
          status_share_name: "Bitte teile zuerst deinen Namen mit.",
          status_add_supabase: "Bitte Supabase-URL und Anon-Key eingeben.",
          status_supabase_sdk_fail: "Supabase SDK konnte nicht geladen werden. Seite neu laden.",
          status_start_failed: "Start fehlgeschlagen. Bitte Seite neu laden.",
          status_app_start_fail: "App startete nicht sauber. Bitte Seite neu laden.",
          status_local_mode: "Weiter im lokalen Modus.",
          a2hs_text: "Installiere MaiTribe f\u00FCr das beste Erlebnis",
          a2hs_install: "Installieren",
          spiegel_title: "Dein Spiegel",
          spiegel_sub: "Dein kosmisches Profil",
          spiegel_form_intro: "Um dein astrologisches Profil und Human Design zu berechnen, brauche ich deine Geburtsdaten.",
          spiegel_label_date: "Geburtsdatum",
          spiegel_label_time: "Geburtszeit",
          spiegel_label_timezone: "Zeitzone (UTC)",
          spiegel_label_place: "Geburtsort",
          spiegel_calculate: "Berechnen",
          spiegel_skip: "Sp\u00E4ter",
          spiegel_loading: "Berechne dein Profil...",
          spiegel_astro_title: "Dein Geburtschart",
          spiegel_hd_title: "Human Design",
          spiegel_share: "Profil teilen",
          spiegel_edit_birth: "Geburtsdaten \u00E4ndern",
          spiegel_sun: "Sonne",
          spiegel_moon: "Mond",
          spiegel_rising: "Aszendent",
          spiegel_hd_strategy: "Strategie",
          spiegel_hd_authority: "Autorit\u00E4t",
          spiegel_hd_profile: "Profil",
          spiegel_hd_definition: "Definition",
          spiegel_hd_cross: "Inkarnationskreuz",
          spiegel_hd_defined: "Definiert",
          spiegel_hd_undefined: "Offen",
          spiegel_home_title: "Dein Spiegel",
          spiegel_home_sub: "Dein kosmisches Profil",
          spiegel_home_cta: "Entdecke dein kosmisches Profil \u2192",
          spiegel_home_hd_type: "HD Typ",
          spiegel_birth_saved: "Geburtsdaten gespeichert!",
          spiegel_enter_date: "Bitte gib dein Geburtsdatum ein.",
          spiegel_enter_place: "Bitte gib deinen Geburtsort ein.",
          spiegel_calc_error: "Berechnungsfehler. Bitte versuche es erneut.",
          spiegel_place_placeholder: "z.B. Berlin, Deutschland",
          settings_spiegel_title: "Dein Spiegel",
          settings_spiegel_label: "Kosmisches Profil anzeigen",
          settings_birth_not_set: "Noch nicht eingerichtet"
        }
      };

      const appState = {
        supabase: null,
        session: null,
        currentUser: null,
        currentConversationId: null,
        lastInputWasVoice: false,
        profile: null,
        activeIdentity: null,
        onboarding: {
          step: 1,
          answers: [],
          checkin: null,
          checkinResponse: "",
          generatedIdentity: ""
        },
        config: loadConfig()
      };

      function loadConfig() {
        return {
          supabaseUrl: localStorage.getItem("maitribe.supabase.url") || (window.MAITRIBE_CONFIG && window.MAITRIBE_CONFIG.SUPABASE_URL) || "",
          supabaseAnonKey: localStorage.getItem("maitribe.supabase.anon") || (window.MAITRIBE_CONFIG && window.MAITRIBE_CONFIG.SUPABASE_ANON_KEY) || "",
          geminiApiKey: localStorage.getItem("maitribe.gemini.key") || (window.MAITRIBE_CONFIG && window.MAITRIBE_CONFIG.GEMINI_API_KEY) || "",
          vapidPublicKey: localStorage.getItem("maitribe.vapid.public") || (window.MAITRIBE_CONFIG && window.MAITRIBE_CONFIG.VAPID_PUBLIC_KEY) || ""
        };
      }

      function saveConfig(config) {
        localStorage.setItem("maitribe.supabase.url", config.supabaseUrl || "");
        localStorage.setItem("maitribe.supabase.anon", config.supabaseAnonKey || "");
        localStorage.setItem("maitribe.gemini.key", config.geminiApiKey || "");
        localStorage.setItem("maitribe.vapid.public", config.vapidPublicKey || "");
        appState.config = loadConfig();
      }

      function getEl(id) {
        return document.getElementById(id);
      }

      function setStatus(id, message, isError) {
        const node = getEl(id);
        if (!node) return;
        node.textContent = message || "";
        node.classList.toggle("error", Boolean(isError));
      }

      function showScreen(id) {
        screens.forEach((screenId) => {
          const node = getEl(screenId);
          if (!node) return;
          node.classList.toggle("active", screenId === id);
        });

        updateBottomNavVisibility(id);
        if (["screen-home", "screen-chat", "screen-settings"].includes(id)) {
          setActiveBottomTab(id);
        }
        applyI18n();
      }

      function updateBottomNavVisibility(screenId) {
        const nav = getEl("bottom-nav");
        const shouldShow = Boolean(appState.session && appState.profile && appState.profile.onboarding_completed) && ["screen-home", "screen-chat", "screen-settings"].includes(screenId);
        nav.style.display = shouldShow ? "grid" : "none";
      }

      function setActiveBottomTab(screenId) {
        const nav = getEl("bottom-nav");
        nav.querySelectorAll("button").forEach((button) => {
          button.classList.toggle("active", button.getAttribute("data-target") === screenId);
        });
      }

      function detectDefaultLanguage() {
        const base = (navigator.language || "en").slice(0, 2).toLowerCase();
        return languageMap[base] ? base : "en";
      }

      function detectTimezone() {
        try {
          return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
        } catch (_) {
          return "UTC";
        }
      }

      function getLanguageName(code) {
        return languageMap[code] || "English";
      }

      function getCurrentLanguage() {
        const onboardingSelect = getEl("onboard-language");
        const onboardingScreen = getEl("screen-onboarding");
        const inOnboarding = onboardingScreen && onboardingScreen.classList.contains("active");
        if (inOnboarding && onboardingSelect && onboardingSelect.value) return onboardingSelect.value;
        return (appState.profile && appState.profile.language) || (onboardingSelect && onboardingSelect.value) || "en";
      }

      function t(key) {
        const lang = getCurrentLanguage();
        return (i18n[lang] && i18n[lang][key]) || (i18n.en && i18n.en[key]) || key;
      }

      function getIdentityQuestions() {
        return [t("identity_q1"), t("identity_q2"), t("identity_q3"), t("identity_q4")];
      }

      function getGreeting(name, hour) {
        var key;
        if (hour < 5) key = "greeting_night";
        else if (hour < 12) key = "greeting_morning";
        else if (hour < 17) key = "greeting_afternoon";
        else if (hour < 21) key = "greeting_evening";
        else key = "greeting_late";

        var template = t(key);
        if (!name) return template.replace(", {name}", "").replace(" {name}", "");
        return template.replace("{name}", name);
      }

      function getFallbackOpening() {
        var name = (appState.profile && (appState.profile.display_name || appState.profile.name)) || "";
        var lang = getCurrentLanguage();
        var openings;
        if (lang === "de") {
          openings = name
            ? [
              "Hey " + name + ". Wie geht\u2019s?",
              "Hey " + name + ". Was ist los?",
              "Hey " + name + ". Wie l\u00E4uft\u2019s?"
            ]
            : [
              "Hey. Wie geht\u2019s?",
              "Hey. Was ist los?",
              "Hey. Wie l\u00E4uft\u2019s?"
            ];
        } else {
          openings = name
            ? [
              "Hey " + name + ". How are you?",
              "Hey " + name + ". What\u2019s up?",
              "Hey " + name + ". How\u2019s it going?"
            ]
            : [
              "Hey. How are you?",
              "Hey. What\u2019s up?",
              "Hey. How\u2019s it going?"
            ];
        }
        return openings[Math.floor(Math.random() * openings.length)];
      }

      function setText(id, text) {
        const node = getEl(id);
        if (node) node.textContent = text;
      }

      function applyI18n() {
        var splashSub = getEl("splash-subtitle");
        if (splashSub) splashSub.textContent = t("splash_subtitle");

        setText("auth-subtitle", t("auth_subtitle"));
        setText("auth-email-label", t("auth_email_label"));
        setText("btn-magic-link", t("auth_continue_email"));
        setText("btn-google", t("auth_continue_google"));
        setText("auth-project-keys-summary", t("auth_project_keys"));
        setText("btn-save-config", t("auth_save_keys"));
        setText("auth-keys-helper", t("auth_keys_helper"));

        setText("onboard-welcome-title", t("onboard_welcome_title"));
        setText("onboard-welcome-text", t("onboard_welcome_text"));
        setText("btn-onboard-begin", t("onboard_begin"));
        setText("onboard-step2-title", t("onboard_step2_title"));
        setText("onboard-name-label", t("onboard_name_label"));
        setText("onboard-language-label", t("onboard_language_label"));
        setText("onboard-timezone-label", t("onboard_timezone_label"));
        setText("btn-onboard-step2", t("onboard_continue"));
        setText("onboard-checkin-title", t("onboard_checkin_title"));
        setText("onboard-checkin-sub", t("onboard_checkin_sub"));
        setText("onboard-checkin-note-label", t("onboard_checkin_note_label"));
        setText("btn-onboard-checkin", t("onboard_checkin_btn"));
        setText("btn-onboard-step3-next", t("onboard_continue"));
        setText("onboard-label-body", t("slider_body"));
        setText("onboard-label-mind", t("slider_mind"));
        setText("onboard-label-soul", t("slider_soul"));
        setText("onboard-label-energy", t("slider_energy"));
        setText("onboard-identity-title", t("onboard_identity_title"));
        setText("onboard-identity-sub", t("onboard_identity_sub"));
        setText("onboard-identity-generated-label", t("onboard_identity_generated_label"));
        var identityIdx = appState.onboarding.answers ? appState.onboarding.answers.length : 0;
        setText("btn-identity-next", identityIdx >= getIdentityQuestions().length - 1 ? t("identity_generate") : t("identity_save_answer"));
        setText("onboard-reminders-title", t("onboard_reminders_title"));
        setText("onboard-wake-label", t("onboard_wake_label"));
        setText("onboard-morning-label", t("onboard_morning_label"));
        setText("onboard-morning-help", t("onboard_morning_help"));
        setText("onboard-mindful-label", t("onboard_mindful_label"));
        setText("onboard-mindful-help", t("onboard_mindful_help"));
        setText("onboard-mindful-count-label", t("onboard_mindful_count_label"));
        setText("btn-request-notifications", t("onboard_notify"));
        setText("btn-onboard-finish", t("onboard_ready"));

        setText("home-checkin-title", t("home_checkin_title"));
        setText("home-checkin-badge", t("home_checkin_badge"));
        setText("home-checkin-btn", t("home_checkin_btn"));
        setText("home-identity-title", t("home_identity_label"));
        setText("home-identity-sub", t("home_identity_sub"));
        setText("home-recent-label", t("home_recent"));
        setText("home-mini-body", t("home_mini_body"));
        setText("home-mini-mind", t("home_mini_mind"));
        setText("home-mini-soul", t("home_mini_soul"));
        setText("home-mini-energy", t("home_mini_energy"));
        var idSentence = getEl("home-identity-sentence");
        if (idSentence && (idSentence.textContent === "Your truth will appear here once onboarding is complete." || idSentence.textContent === "Deine Wahrheit erscheint hier nach dem Onboarding.")) {
          setText("home-identity-sentence", t("home_identity_placeholder"));
        }
        setText("checkin-screen-title", t("checkin_title"));
        setText("btn-checkin-back", t("checkin_back"));
        setText("checkin-note-label", t("checkin_note_label"));
        setText("btn-checkin-submit", t("checkin_submit"));
        setText("checkin-label-body", t("slider_body"));
        setText("checkin-label-mind", t("slider_mind"));
        setText("checkin-label-soul", t("slider_soul"));
        setText("checkin-label-energy", t("slider_energy"));

        setText("identity-screen-title", t("identity_title"));
        setText("btn-identity-back", t("identity_back"));
        setText("btn-identity-edit", t("identity_edit"));
        setText("btn-identity-cancel", t("identity_cancel"));
        setText("btn-identity-save", t("identity_save"));
        setText("identity-edit-label", t("identity_edit_label"));
        var idView = getEl("identity-view");
        if (idView && (idView.textContent === "No identity found yet." || idView.textContent === "Noch keine Identit\u00E4t erstellt.")) {
          setText("identity-view", t("identity_empty"));
        }

        setText("settings-title", t("settings_title"));
        setText("btn-logout", t("settings_logout"));
        setText("settings-profile-title", t("settings_profile"));
        setText("settings-name-label", t("settings_name_label"));
        setText("settings-language-label", t("settings_language_label"));
        setText("settings-timezone-label", t("settings_timezone_label"));
        setText("settings-reminders-title", t("settings_reminders"));
        setText("settings-morning-time-label", t("settings_morning_time"));
        setText("settings-morning-enabled-label", t("settings_morning_enabled"));
        setText("settings-mindful-enabled-label", t("settings_mindful_enabled"));
        setText("settings-mindful-count-label", t("settings_mindful_count"));
        setText("settings-event-enabled-label", t("settings_event_enabled"));
        setText("settings-keys-title", t("settings_keys"));
        setText("settings-gemini-label", t("settings_gemini_label"));
        setText("settings-vapid-label", t("settings_vapid_label"));
        setText("btn-settings-save", t("settings_save"));
        setText("btn-settings-push", t("settings_push"));
        setText("btn-settings-test-push", t("settings_test_push"));
        setText("settings-privacy-link", t("settings_privacy_link"));
        setText("settings-spiegel-title", t("settings_spiegel_title"));
        setText("settings-spiegel-label", t("settings_spiegel_label"));

        setText("nav-home-label", t("nav_home"));
        setText("nav-chat-label", t("nav_mai"));
        setText("nav-profile-label", t("nav_profile"));

        // Profile stats labels
        var statLabels = document.querySelectorAll(".profile-stat-label");
        if (statLabels.length >= 3) {
          statLabels[0].textContent = t("profile_stat_checkins");
          statLabels[1].textContent = t("profile_stat_chats");
          statLabels[2].textContent = t("profile_stat_days");
        }

        // Spiegel i18n
        setText("spiegel-title", t("spiegel_title"));
        setText("spiegel-sub", t("spiegel_sub"));
        setText("spiegel-form-intro", t("spiegel_form_intro"));
        setText("spiegel-label-date", t("spiegel_label_date"));
        setText("spiegel-label-time", t("spiegel_label_time"));
        setText("spiegel-label-timezone", t("spiegel_label_timezone"));
        setText("spiegel-label-place", t("spiegel_label_place"));
        setText("btn-spiegel-calculate", t("spiegel_calculate"));
        setText("btn-spiegel-skip", t("spiegel_skip"));
        setText("spiegel-loading-text", t("spiegel_loading"));
        setText("spiegel-astro-title", t("spiegel_astro_title"));
        setText("spiegel-hd-title", t("spiegel_hd_title"));
        setText("spiegel-share-label", t("spiegel_share"));
        setText("btn-spiegel-edit", t("spiegel_edit_birth"));
        setText("home-spiegel-title", t("spiegel_home_title"));
        setText("home-spiegel-sub", t("spiegel_home_sub"));
        setText("home-spiegel-cta", t("spiegel_home_cta"));
        setText("home-spiegel-sun-label", t("spiegel_sun"));
        setText("home-spiegel-moon-label", t("spiegel_moon"));
        setText("home-spiegel-type-label", t("spiegel_home_hd_type"));
        var spiegelPlaceInput = getEl("spiegel-birth-place");
        if (spiegelPlaceInput) spiegelPlaceInput.placeholder = t("spiegel_place_placeholder");

        // Big three labels
        var bigLabels = document.querySelectorAll(".spiegel-big-label");
        if (bigLabels.length >= 3) {
          bigLabels[0].textContent = t("spiegel_sun");
          bigLabels[1].textContent = t("spiegel_moon");
          bigLabels[2].textContent = t("spiegel_rising");
        }

        const chatInput = getEl("chat-input");
        if (chatInput) chatInput.placeholder = t("chat_input_placeholder");
        const onboardNote = getEl("onboard-note");
        if (onboardNote) onboardNote.placeholder = t("onboard_checkin_note_placeholder");
        const identityAnswer = getEl("identity-answer");
        if (identityAnswer) identityAnswer.placeholder = t("onboard_identity_placeholder");
        const checkinNote = getEl("checkin-note");
        if (checkinNote) checkinNote.placeholder = t("checkin_note_placeholder");

        if (appState.profile) {
          const name = appState.profile.display_name || appState.profile.name || "";
          setText("home-greeting", getGreeting(name, new Date().getHours()));
        }

        const emptyState = getEl("chat-empty-state");
        if (emptyState) {
          emptyState.innerHTML = t("chat_empty").replace(/\n/g, "<br>");
        }

        if (appState.onboarding.step === 4) {
          renderIdentityQuestion();
        }
      }

      function safeJsonParse(text, fallback) {
        try {
          return JSON.parse(text);
        } catch (_) {
          return fallback;
        }
      }

      function splitIdentitySentences(identityText) {
        return identityText
          .split(/(?<=[.!?])\s+/)
          .map((s) => s.trim())
          .filter(Boolean);
      }

      function updateRangeOutputs(prefix) {
        ["body", "mind", "soul", "energy"].forEach((key) => {
          const slider = getEl(prefix + "-" + key);
          const output = getEl(prefix + "-" + key + "-val");
          if (!slider || !output) return;
          output.textContent = slider.value;
          styleSlider(slider, output);
          slider.addEventListener("input", () => {
            output.textContent = slider.value;
            styleSlider(slider, output);
          });
        });
      }

      function styleSlider(slider, output) {
        const value = Number(slider.value || 5);
        let color = "#a8c5a0";
        if (value <= 3) color = "#c67f7f";
        else if (value <= 6) color = "#c9b88c";

        slider.style.setProperty("--track-color", color);
        output.style.color = color;
      }

      function softGeminiErrorMessage(code, status) {
        if (code === "no_key") return t("err_no_key");
        if (code === "timeout") return t("err_timeout");
        if (status === 429) return t("err_rate_limit");
        if (status === 400 || status === 403) return t("err_invalid_key");
        return t("err_api");
      }

      function buildLocalCheckinFallback(args) {
        const langCode = (args && args.context && args.context.user && args.context.user.language) || getCurrentLanguage() || "en";
        const body = Number(args.body || 5);
        const mind = Number(args.mind || 5);
        const soul = Number(args.soul || 5);
        const energy = Number(args.energy || 5);
        const avg = (body + mind + soul + energy) / 4;
        const lowState = avg <= 4.5 || Math.min(body, mind, soul, energy) <= 3;

        if (langCode === "de") {
          if (lowState) {
            return "Danke, dass du das so ehrlich teilst. Wenn sich alles nach Nullpunkt anf\u00FChlt, ist schon dieses Einchecken ein mutiger Schritt. Was w\u00FCrde dir in den n\u00E4chsten 10 Minuten ein kleines Gef\u00FChl von Halt geben?";
          }
          return "Danke f\u00FCr deinen ehrlichen Check-in. Ich sehe, dass gerade vieles gleichzeitig da ist. Was w\u00E4re jetzt ein kleiner, sanfter Schritt, der dir wirklich gut tun w\u00FCrde?";
        }

        if (lowState) {
          return "Thank you for being this honest. When everything feels close to zero, this check-in is already a brave step. What could give you even a small sense of steadiness in the next 10 minutes?";
        }
        return "Thank you for checking in so honestly. I can feel there is a lot here at once. What is one gentle next step that would truly support you right now?";
      }

      async function withTimeout(promise, ms, label) {
        let timeoutId = null;
        const timeoutPromise = new Promise((_, reject) => {
          timeoutId = setTimeout(() => {
            reject(new Error((label || "Request") + " timed out"));
          }, ms);
        });

        try {
          return await Promise.race([promise, timeoutPromise]);
        } finally {
          if (timeoutId) clearTimeout(timeoutId);
        }
      }

      function extractMissingColumnName(error) {
        var raw = [error && error.message, error && error.details, error && error.hint].filter(Boolean).join(" ");
        if (!raw) return null;
        var patterns = [
          /Could not find the ['"]([a-zA-Z0-9_]+)['"] column/i,
          /column ['"]?([a-zA-Z0-9_]+)['"]? does not exist/i,
          /record ["']?[a-zA-Z0-9_]+["']? has no field ["']([a-zA-Z0-9_]+)["']/i
        ];
        for (var i = 0; i < patterns.length; i += 1) {
          var match = raw.match(patterns[i]);
          if (match && match[1]) return match[1];
        }
        return null;
      }

      function removeColumnIfPresent(payload, columnName) {
        if (!payload || !columnName || !Object.prototype.hasOwnProperty.call(payload, columnName)) return false;
        delete payload[columnName];
        return true;
      }

      async function upsertUsersSafe(payload, options) {
        if (!appState.supabase) return { data: null, error: { message: "Supabase not initialized." } };
        var nextPayload = { ...(payload || {}) };
        for (var attempt = 0; attempt < 8; attempt += 1) {
          var result = await appState.supabase.from("users").upsert(nextPayload, options || { onConflict: "id" });
          if (!result.error) return result;

          var missingColumn = extractMissingColumnName(result.error);
          var removed = removeColumnIfPresent(nextPayload, missingColumn);
          if (removed) {
            console.warn("[MaiTribe] users upsert dropped unknown column:", missingColumn);
            continue;
          }
          return result;
        }
        return { data: null, error: { message: "Users upsert failed after schema retries." } };
      }

      async function updateUsersSafe(userId, payload) {
        if (!appState.supabase) return { data: null, error: { message: "Supabase not initialized." } };
        var nextPayload = { ...(payload || {}) };
        for (var attempt = 0; attempt < 8; attempt += 1) {
          var result = await appState.supabase.from("users").update(nextPayload).eq("id", userId);
          if (!result.error) return result;

          var missingColumn = extractMissingColumnName(result.error);
          var removed = removeColumnIfPresent(nextPayload, missingColumn);
          if (removed) {
            console.warn("[MaiTribe] users update dropped unknown column:", missingColumn);
            continue;
          }
          return result;
        }
        return { data: null, error: { message: "Users update failed after schema retries." } };
      }

      function fillConfigInputs() {
        getEl("cfg-supabase-url").value = appState.config.supabaseUrl;
        getEl("cfg-supabase-key").value = appState.config.supabaseAnonKey;
        getEl("cfg-gemini-key").value = appState.config.geminiApiKey;
        getEl("cfg-vapid-key").value = appState.config.vapidPublicKey;
        getEl("settings-gemini").value = appState.config.geminiApiKey;
        getEl("settings-vapid").value = appState.config.vapidPublicKey;
      }

      async function initializeSupabase() {
        if (!appState.config.supabaseUrl || !appState.config.supabaseAnonKey) {
          console.warn("[MaiTribe] initializeSupabase: missing config", { url: !!appState.config.supabaseUrl, key: !!appState.config.supabaseAnonKey });
          appState.supabase = null;
          return false;
        }
        if (!window.supabase || typeof window.supabase.createClient !== "function") {
          console.error("[MaiTribe] initializeSupabase: Supabase SDK not found on window");
          appState.supabase = null;
          setStatus("config-status", t("status_supabase_sdk_fail"), true);
          return false;
        }
        try {
          appState.supabase = window.supabase.createClient(appState.config.supabaseUrl, appState.config.supabaseAnonKey, {
            auth: {
              flowType: 'implicit',
              autoRefreshToken: true,
              persistSession: true,
              detectSessionInUrl: true,
              storageKey: 'maitribe-auth',
              lock: false
            }
          });
          console.log("[MaiTribe] Supabase client created OK");
          return true;
        } catch (err) {
          console.error("[MaiTribe] createClient threw:", err);
          appState.supabase = null;
          return false;
        }
      }

      // Capture hash fragment immediately before anything can consume it
      var _capturedHash = window.location.hash || "";

      function getAuthRedirectUrl() {
        const url = new URL(window.location.href);
        url.hash = "";
        url.searchParams.set("no_sw", "1");
        url.searchParams.set("auth", "1");
        return url.toString();
      }

      function cleanupAuthUrl() {
        const url = new URL(window.location.href);
        [
          "code",
          "token_hash",
          "type",
          "access_token",
          "refresh_token",
          "expires_in",
          "expires_at",
          "provider_token",
          "provider_refresh_token",
          "auth",
          "error",
          "error_description",
          "error_code"
        ].forEach((param) => url.searchParams.delete(param));
        url.hash = "";
        window.history.replaceState({}, "", url.toString());
        _capturedHash = "";
      }

      function parseHashParams() {
        var raw = _capturedHash || window.location.hash || "";
        if (raw.startsWith("#")) raw = raw.slice(1);
        if (!raw) return {};
        var result = {};
        raw.split("&").forEach(function (pair) {
          var parts = pair.split("=");
          if (parts[0]) result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || "");
        });
        return result;
      }

      async function processAuthRedirect() {
        var url = new URL(window.location.href);
        var code = url.searchParams.get("code");
        var tokenHash = url.searchParams.get("token_hash");
        var type = url.searchParams.get("type");
        var hashParams = parseHashParams();
        var accessToken = hashParams["access_token"] || null;
        var refreshToken = hashParams["refresh_token"] || null;
        var hashError = hashParams["error"] || null;
        var hashErrorDesc = hashParams["error_description"] || null;

        // Check for auth errors in hash (e.g. expired magic link)
        if (hashError) {
          cleanupAuthUrl();
          return { error: { message: hashErrorDesc || hashError } };
        }

        // Check for auth errors in query params
        var queryError = url.searchParams.get("error");
        var queryErrorDesc = url.searchParams.get("error_description");
        if (queryError) {
          cleanupAuthUrl();
          return { error: { message: queryErrorDesc || queryError } };
        }

        // PKCE flow: exchange code for session
        if (code) {
          var codeResult = await appState.supabase.auth.exchangeCodeForSession(code);
          if (!codeResult.error) cleanupAuthUrl();
          return { error: codeResult.error || null };
        }

        // Magic link hash tokens: access_token + refresh_token in fragment
        if (accessToken && refreshToken) {
          var tokenResult = await appState.supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken
          });
          if (!tokenResult.error) cleanupAuthUrl();
          return { error: tokenResult.error || null };
        }

        // Hash may also contain token_hash + type (email OTP verification)
        var hashTokenHash = hashParams["token_hash"] || null;
        var hashType = hashParams["type"] || null;
        if (hashTokenHash && hashType) {
          var otpResult = await appState.supabase.auth.verifyOtp({
            type: hashType,
            token_hash: hashTokenHash
          });
          if (!otpResult.error) cleanupAuthUrl();
          return { error: otpResult.error || null };
        }

        // Query param token_hash + type (alternative OTP flow)
        if (tokenHash && type) {
          var otpResult2 = await appState.supabase.auth.verifyOtp({
            type: type,
            token_hash: tokenHash
          });
          if (!otpResult2.error) cleanupAuthUrl();
          return { error: otpResult2.error || null };
        }

        // No auth params found — not a redirect callback
        return { error: null };
      }

      async function routeAfterSplash() {
        try {
          const hasSupabase = await initializeSupabase();
          if (!hasSupabase) {
            _bootRouteComplete = true;
            showScreen("screen-auth");
            if (!getEl("config-status").textContent) {
              setStatus("config-status", t("status_add_supabase"), true);
            }
            return;
          }

          // Ensure auth listener is attached now that Supabase is ready
          registerAuthListener();

          // Hash token: let Supabase process it natively via getSession, then clean URL
          const hashParams = parseHashParams();
          if (hashParams['access_token']) {
            const { data } = await appState.supabase.auth.getSession();
            window.history.replaceState({}, '', window.location.origin + window.location.pathname);
            _capturedHash = '';
            if (data && data.session) {
              _bootRouteComplete = true;
              await handleSession(data.session);
              return;
            }
          }

          const callbackResult = await processAuthRedirect();
          if (callbackResult.error) {
            _bootRouteComplete = true;
            showScreen("screen-auth");
            var errMsg = (callbackResult.error && callbackResult.error.message) || "";
            setStatus("auth-status", errMsg || t("status_magic_expired"), true);
            return;
          }

          const { data } = await appState.supabase.auth.getSession();
          const session = data ? data.session : null;
          console.log("[MaiTribe] getSession result:", session ? session.user.email : "no session");

          _bootRouteComplete = true;
          if (session) {
            await handleSession(session);
          } else {
            showScreen("screen-auth");
          }
        } catch (error) {
          console.error("[MaiTribe] routeAfterSplash error:", error);
          _bootRouteComplete = true;
          showScreen("screen-auth");
          setStatus("config-status", t("status_start_failed"), true);
        }
      }

      async function handleSession(session) {
        console.log("[MaiTribe] handleSession for:", session.user.email);
        appState.session = session;
        appState.currentUser = session.user;

        // Degraded-mode approach: each DB step is best-effort.
        // If any fails, we still have auth data and can show the app.
        try { await ensureUserProfile(session.user); } catch (e) { console.error("[MaiTribe] ensureUserProfile failed:", e); }
        try { await loadProfile(); } catch (e) { console.error("[MaiTribe] loadProfile failed:", e); }

        // Build a minimal profile from auth data if DB profile unavailable
        if (!appState.profile) {
          console.warn("[MaiTribe] Using degraded profile from auth session");
          var meta = session.user.user_metadata || {};
          appState.profile = {
            id: session.user.id,
            email: session.user.email,
            name: meta.name || meta.full_name || "",
            display_name: meta.name || meta.full_name || "",
            language: detectDefaultLanguage(),
            timezone: detectTimezone(),
            onboarding_completed: false
          };
        }

        applyI18n();

        if (!appState.profile.onboarding_completed) {
          prepareOnboardingFromProfile();
          showScreen("screen-onboarding");
          return;
        }

        try { await loadHomeScreen(); } catch (e) { console.error("[MaiTribe] loadHomeScreen failed:", e); }
        try { await loadIdentityScreen(); } catch (e) { console.error("[MaiTribe] loadIdentityScreen failed:", e); }
        try { populateSettingsFromProfile(); } catch (e) { console.error("[MaiTribe] populateSettings failed:", e); }
        showScreen("screen-home");
      }

      async function ensureUserProfile(user) {
        if (!appState.supabase || !user) return;

        var guessedName = (user.user_metadata && (user.user_metadata.name || user.user_metadata.full_name)) || "";

        // Insert only if user row doesn't exist yet — never overwrite existing name/display_name
        var { error: insertError } = await upsertUsersSafe({
          id: user.id,
          email: user.email,
          name: guessedName || null,
          display_name: guessedName || null,
          language: detectDefaultLanguage(),
          timezone: detectTimezone(),
          last_active_at: new Date().toISOString()
        }, { onConflict: "id", ignoreDuplicates: true });
        if (insertError) console.error("[MaiTribe] ensureUserProfile insert error:", insertError);

        // Always update last_active_at for returning users (without touching name)
        var { error: updateError } = await updateUsersSafe(user.id, { last_active_at: new Date().toISOString() });
        if (updateError) console.error("[MaiTribe] ensureUserProfile update error:", updateError);
      }

      async function loadProfile() {
        if (!appState.supabase || !appState.currentUser) return;
        const { data, error } = await appState.supabase
          .from("users")
          .select("*")
          .eq("id", appState.currentUser.id)
          .single();

        if (error) {
          setStatus("auth-status", t("status_could_not_load_profile"), true);
          return;
        }

        appState.profile = data;
      }

      function prepareOnboardingFromProfile() {
        appState.onboarding.step = Math.max(1, (appState.profile && appState.profile.onboarding_step ? appState.profile.onboarding_step + 1 : 1));
        appState.onboarding.answers = [];
        appState.onboarding.generatedIdentity = "";

        getEl("onboard-name").value = (appState.profile && (appState.profile.display_name || appState.profile.name)) || "";
        getEl("onboard-language").value = (appState.profile && appState.profile.language) || detectDefaultLanguage();
        getEl("onboard-timezone").value = (appState.profile && appState.profile.timezone) || detectTimezone();
        applyI18n();
        setOnboardingStep(appState.onboarding.step);
      }

      function setOnboardingStep(step) {
        appState.onboarding.step = step;
        const lang = (getEl("onboard-language") && getEl("onboard-language").value) || (appState.profile && appState.profile.language) || "en";
        getEl("onboard-progress").textContent = t("onboard_step_progress").replace("{step}", step);
        [1, 2, 3, 4, 5].forEach((idx) => {
          getEl("onboard-step-" + idx).classList.toggle("active", idx === step);
        });
        if (step === 4) {
          renderIdentityQuestion();
        }
      }

      function renderIdentityQuestion() {
        const index = appState.onboarding.answers.length;
        const promptNode = getEl("identity-question");
        const questions = getIdentityQuestions();

        if (index < questions.length) {
          promptNode.textContent = questions[index];
          getEl("identity-answer").value = "";
          getEl("btn-identity-next").textContent = index === questions.length - 1 ? t("identity_generate") : t("identity_save_answer");
          getEl("identity-generated-wrap").classList.add("hidden");
        } else {
          promptNode.textContent = t("identity_generating");
        }
      }

      async function generateIdentityFromAnswers() {
        const answers = appState.onboarding.answers;
        const languageCode = getEl("onboard-language").value;
        const lang = getLanguageName(languageCode);
        const prompt = `You are Mai. You just had a deep onboarding conversation.

Their answers about their life:
- Dream life (where, what, how it feels): ${answers[0]}
- What matters most: ${answers[1]}
- Feeling they want more of: ${answers[2]}
- Secret dream: ${answers[3]}

Write their personal Identity statement. Rules:
- 6-8 sentences in first person ("I am...", "I choose...", "I trust...")
- Make it feel TRUE, not aspirational-fake. Grounded, not fluffy.
- Include: their body, their mind, their relationships, their purpose, their dream.
- Use THEIR specific words and details — don't generalize.
- If they mentioned a place, include it specifically.
- If they mentioned a feeling, anchor it in a concrete image.
- End with something grounding — quiet power, not hype.
- Do NOT use phrases like "I am worthy" or "I deserve" — too generic.
- Write like a poet, not a life coach.

Write in ${lang}.`;

        var skipShown = false;
        var timeoutId = setTimeout(function() {
          if (!skipShown) {
            skipShown = true;
            showIdentitySkipButton();
            setStatus("identity-status", t("identity_timeout_msg"), false);
          }
        }, 30000);

        try {
          const responseResult = await callGeminiRaw(prompt, 500);
          clearTimeout(timeoutId);
          const identity = responseResult.text || fallbackIdentity(answers, languageCode);
          appState.onboarding.generatedIdentity = identity;

          getEl("identity-generated").value = identity;
          getEl("identity-generated-wrap").classList.remove("hidden");
          hideIdentitySkipButton();
          if (responseResult.error) {
            showIdentitySkipButton();
            setStatus("identity-status", responseResult.error.message + " " + t("status_fallback_generated"), false);
            return;
          }
          setStatus("identity-status", t("status_review_identity"), false);
        } catch (e) {
          console.error("[MaiTribe] generateIdentityFromAnswers error:", e);
          clearTimeout(timeoutId);
          var identity = fallbackIdentity(answers, languageCode);
          appState.onboarding.generatedIdentity = identity;
          getEl("identity-generated").value = identity;
          getEl("identity-generated-wrap").classList.remove("hidden");
          showIdentitySkipButton();
          setStatus("identity-status", t("identity_timeout_msg"), false);
        }
      }

      function showIdentitySkipButton() {
        var existing = document.getElementById("btn-identity-skip");
        if (existing) { existing.classList.remove("hidden"); return; }
        var btn = document.createElement("button");
        btn.id = "btn-identity-skip";
        btn.className = "btn";
        btn.type = "button";
        btn.style.marginTop = "8px";
        btn.textContent = t("identity_skip");
        btn.addEventListener("click", function() {
          var answers = appState.onboarding.answers;
          var languageCode = getEl("onboard-language").value;
          if (!appState.onboarding.generatedIdentity) {
            appState.onboarding.generatedIdentity = fallbackIdentity(answers, languageCode);
          }
          getEl("identity-generated").value = appState.onboarding.generatedIdentity;
          getEl("identity-generated-wrap").classList.remove("hidden");
          hideIdentitySkipButton();
          setStatus("identity-status", t("status_review_identity"), false);
        });
        var statusEl = getEl("identity-status");
        statusEl.parentNode.insertBefore(btn, statusEl.nextSibling);
      }

      function hideIdentitySkipButton() {
        var btn = document.getElementById("btn-identity-skip");
        if (btn) btn.classList.add("hidden");
      }

      function fallbackIdentity(answers, languageCode) {
        if (languageCode === "de") {
          return "Ich lebe ein Leben, das sich echt anf\u00FChlt \u2014 " +
            "in meinem K\u00F6rper zuhause, in meinem Kopf klar, in meinem Herzen offen. " +
            "Ich richte meine Tage nach dem aus, was mir wirklich wichtig ist. " +
            "Ich w\u00E4hle Beziehungen, in denen Vertrauen und echte N\u00E4he wachsen k\u00F6nnen. " +
            "Ich nehme mir Raum f\u00FCr das, was mich lebendig macht. " +
            "Mein Traum darf sichtbar werden \u2014 Schritt f\u00FCr Schritt. " +
            "Ich gehe meinen Weg mit Ruhe, Mut und einem offenen Herzen.";
        }

        return "I live a life that feels real \u2014 " +
          "at home in my body, clear in my mind, open in my heart. " +
          "I align my days with what truly matters to me. " +
          "I choose relationships where trust and closeness can grow. " +
          "I make space for what makes me feel alive. " +
          "My dream is allowed to become visible \u2014 step by step. " +
          "I walk my path with calm, courage, and an open heart.";
      }

      async function completeOnboarding() {
        if (!appState.supabase || !appState.currentUser) return;

        const finishButton = getEl("btn-onboard-finish");
        const userId = appState.currentUser.id;
        const name = getEl("onboard-name").value.trim();
        const language = getEl("onboard-language").value;
        const timezone = getEl("onboard-timezone").value.trim() || detectTimezone();
        const wakeTime = getEl("onboard-wake-time").value || "07:00";
        const morningEnabled = getEl("onboard-morning-toggle").checked;
        const mindfulEnabled = getEl("onboard-mindful-toggle").checked;
        const mindfulCount = Number(getEl("onboard-reminder-count").value || 2);
        const identityText = getEl("identity-generated").value.trim();
        const localComplete = (message) => {
          const sentences = splitIdentitySentences(identityText);
          appState.profile = {
            ...(appState.profile || {}),
            id: userId,
            email: (appState.currentUser && appState.currentUser.email) || null,
            name: name,
            display_name: name,
            language: language,
            timezone: timezone,
            morning_reminder_time: wakeTime,
            morning_reminder_enabled: morningEnabled,
            mindful_reminders_enabled: mindfulEnabled,
            mindful_reminder_count: mindfulCount,
            onboarding_completed: true,
            onboarding_step: 5
          };
          appState.activeIdentity = {
            full_text: identityText,
            one_liner: sentences[0] || identityText,
            sentences: sentences
          };
          applyI18n();
          getEl("home-greeting").textContent = getGreeting(name || "", new Date().getHours());
          getEl("home-identity-sentence").textContent = appState.activeIdentity.one_liner;
          getEl("home-recent-insight").textContent = appState.onboarding.checkinResponse || t("status_saved_locally");
          getEl("identity-view").textContent = identityText;
          getEl("identity-edit-text").value = identityText;
          populateSettingsFromProfile();
          setStatus("onboard-finish-status", message || t("status_local_mode"), false);
          showScreen("screen-home");
        };

        if (!name) {
          setStatus("onboard-finish-status", t("status_add_name"), true);
          setOnboardingStep(2);
          return;
        }

        if (!identityText) {
          setStatus("onboard-finish-status", t("status_generate_identity"), true);
          setOnboardingStep(4);
          return;
        }

        finishButton.disabled = true;
        localComplete(t("status_local_mode"));
        finishButton.disabled = false;

        const syncPayload = {
          userId: userId,
          profile: {
            id: userId,
            email: appState.currentUser.email || null,
            name: name,
            display_name: name,
            language: language,
            timezone: timezone,
            morning_reminder_time: wakeTime,
            morning_reminder_enabled: morningEnabled,
            mindful_reminders_enabled: mindfulEnabled,
            mindful_reminder_count: mindfulCount,
            onboarding_completed: true,
            onboarding_step: 5,
            last_active_at: new Date().toISOString()
          },
          identityText: identityText,
          checkin: appState.onboarding.checkin ? {
            ...appState.onboarding.checkin,
            mai_response: appState.onboarding.checkinResponse || null
          } : null
        };

        syncOnboardingInBackground(syncPayload);
      }

      async function syncOnboardingInBackground(payload) {
        if (!appState.supabase || !payload || !payload.userId) return;
        try {
          var profileResult = await withTimeout(upsertUsersSafe(payload.profile, { onConflict: "id" }), 45000, "Profile save");
          if (profileResult && profileResult.error) throw profileResult.error;

          await withTimeout(
            appState.supabase
              .from("identities")
              .update({ is_active: false })
              .eq("user_id", payload.userId)
              .eq("is_active", true),
            30000,
            "Identity archive"
          );

          const sentences = splitIdentitySentences(payload.identityText);
          await withTimeout(
            appState.supabase.from("identities").insert({
              user_id: payload.userId,
              full_text: payload.identityText,
              one_liner: sentences[0] || payload.identityText,
              sentences: sentences,
              is_active: true
            }),
            30000,
            "Identity save"
          );

          if (payload.checkin) {
            await withTimeout(
              appState.supabase.from("checkins").insert({
                user_id: payload.userId,
                body: payload.checkin.body,
                mind: payload.checkin.mind,
                soul: payload.checkin.soul,
                energy: payload.checkin.energy,
                note: payload.checkin.note || null,
                mai_response: payload.checkin.mai_response || null
              }),
              30000,
              "Check-in save"
            );
          }

          Promise.allSettled([loadProfile(), loadHomeScreen(), loadIdentityScreen()]).then(() => {
            if (appState.profile) populateSettingsFromProfile();
          });
        } catch (err) {
          console.error("[MaiTribe] syncOnboardingInBackground error:", err);
        }
      }

      async function loadHomeScreen() {
        if (!appState.profile) return;

        const name = appState.profile.display_name || appState.profile.name || "";
        const greeting = getGreeting(name, new Date().getHours());
        getEl("home-greeting").textContent = greeting;

        // Set time-of-day subtitle
        var hour = new Date().getHours();
        var lang = getCurrentLanguage();
        var dayPart;
        if (lang === "de") {
          dayPart = hour < 12 ? "Morgen" : hour < 17 ? "Nachmittag" : "Abend";
        } else {
          dayPart = hour < 12 ? "Morning" : hour < 17 ? "Afternoon" : "Evening";
        }
        var todayLabel = getEl("home-today-label");
        if (todayLabel) todayLabel.textContent = dayPart;

        const [identityResult, latestCheckinResult, latestAssistantMessage, checkinCount, chatCount] = await Promise.all([
          appState.supabase.from("identities").select("*").eq("user_id", appState.currentUser.id).eq("is_active", true).order("created_at", { ascending: false }).limit(1).maybeSingle(),
          appState.supabase.from("checkins").select("body,mind,soul,energy,mai_response,created_at").eq("user_id", appState.currentUser.id).order("created_at", { ascending: false }).limit(1).maybeSingle(),
          appState.supabase.from("messages").select("content, created_at").eq("user_id", appState.currentUser.id).eq("role", "assistant").order("created_at", { ascending: false }).limit(1).maybeSingle(),
          appState.supabase.from("checkins").select("id", { count: "exact", head: true }).eq("user_id", appState.currentUser.id),
          appState.supabase.from("conversations").select("id", { count: "exact", head: true }).eq("user_id", appState.currentUser.id)
        ]);

        const identity = identityResult.data;
        appState.activeIdentity = identity || null;

        if (identity && identity.sentences && identity.sentences.length) {
          const seed = Number(new Date().toISOString().slice(8, 10));
          const idx = seed % identity.sentences.length;
          getEl("home-identity-sentence").textContent = identity.sentences[idx];
        } else if (identity && identity.full_text) {
          getEl("home-identity-sentence").textContent = identity.full_text;
        } else {
          getEl("home-identity-sentence").textContent = t("identity_empty");
        }

        // Update identity evidence counter
        var evidenceEl = getEl("home-identity-evidence");
        if (evidenceEl && identity && identity.sentences) {
          var n = identity.sentences.length;
          evidenceEl.textContent = lang === "de"
            ? (n + " Beweis" + (n !== 1 ? "e" : "") + " diese Woche")
            : (n + " evidence" + (n !== 1 ? "s" : "") + " this week");
        }

        // Update mini check-in bars and values
        var lastCheckin = latestCheckinResult.data;
        var vals = lastCheckin
          ? [lastCheckin.body || 0, lastCheckin.mind || 0, lastCheckin.soul || 0, lastCheckin.energy || 0]
          : [0, 0, 0, 0];
        var miniEl = getEl("home-checkin-mini");
        if (miniEl) {
          var fills = miniEl.querySelectorAll(".checkin-mini-fill");
          fills.forEach(function(fill, i) { fill.style.width = (vals[i] * 10) + "%"; });
        }
        var valIds = ["home-mini-body-val", "home-mini-mind-val", "home-mini-soul-val", "home-mini-energy-val"];
        valIds.forEach(function(id, i) {
          var el = getEl(id);
          if (el) el.textContent = String(vals[i]);
        });

        const checkinInsight = lastCheckin && lastCheckin.mai_response;
        const messageInsight = latestAssistantMessage.data && latestAssistantMessage.data.content;
        getEl("home-recent-insight").textContent = checkinInsight || messageInsight || t("home_no_insight");

        // Update profile stats on settings screen
        var statCheckins = getEl("stat-checkins");
        var statChats = getEl("stat-chats");
        var statDays = getEl("stat-days");
        if (statCheckins) statCheckins.textContent = String(checkinCount.count || 0);
        if (statChats) statChats.textContent = String(chatCount.count || 0);
        if (statDays && appState.profile.created_at) {
          var daysDiff = Math.max(1, Math.floor((Date.now() - new Date(appState.profile.created_at).getTime()) / 86400000));
          statDays.textContent = String(daysDiff);
        }

        // Update Dein Spiegel home card
        updateHomeSpiegelCard();
      }

      async function loadIdentityScreen() {
        const { data } = await appState.supabase
          .from("identities")
          .select("*")
          .eq("user_id", appState.currentUser.id)
          .eq("is_active", true)
          .order("created_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        appState.activeIdentity = data || null;
        getEl("identity-view").textContent = (data && data.full_text) || t("identity_empty");
        getEl("identity-edit-text").value = (data && data.full_text) || "";
      }

      function populateSettingsFromProfile() {
        if (!appState.profile) return;

        // Populate profile header
        var displayName = appState.profile.display_name || appState.profile.name || "";
        var avatarEl = getEl("profile-avatar");
        var nameEl = getEl("profile-display-name");
        var emailEl = getEl("profile-email");
        if (avatarEl) avatarEl.textContent = displayName ? displayName.charAt(0).toUpperCase() : "?";
        if (nameEl) nameEl.textContent = displayName;
        if (emailEl && appState.currentUser) emailEl.textContent = appState.currentUser.email || "";

        getEl("settings-name").value = appState.profile.display_name || appState.profile.name || "";
        getEl("settings-language").value = appState.profile.language || "en";
        getEl("settings-timezone").value = appState.profile.timezone || detectTimezone();
        getEl("settings-morning-time").value = appState.profile.morning_reminder_time || "07:00";
        getEl("settings-morning-enabled").checked = appState.profile.morning_reminder_enabled !== false;
        getEl("settings-mindful-enabled").checked = appState.profile.mindful_reminders_enabled !== false;
        getEl("settings-mindful-count").value = String(appState.profile.mindful_reminder_count || 2);
        getEl("settings-event-enabled").checked = appState.profile.event_followup_enabled !== false;

        // Birth data info
        var birthInfo = getEl("settings-birth-info");
        if (birthInfo) {
          if (appState.profile.birth_date && appState.profile.astro_profile) {
            var astro = appState.profile.astro_profile;
            var sun = astro && astro.sun ? signName(astro.sun.sign) : "";
            var hd = appState.profile.human_design;
            var hdType = (hd && hd.type && hd.type.name) || "";
            birthInfo.textContent = [sun, hdType].filter(Boolean).join(" \u00B7 ") || appState.profile.birth_place || "";
          } else {
            var lang = getCurrentLanguage();
            birthInfo.textContent = lang === "de" ? "Noch nicht eingerichtet" : "Not set up yet";
          }
        }
      }

      async function saveSettings() {
        if (!appState.supabase || !appState.currentUser) return;

        var newKey = getEl("settings-gemini").value.trim();
        var oldKey = appState.config.geminiApiKey;

        // Validate API key if changed
        if (newKey && newKey !== oldKey) {
          setStatus("settings-status", t("status_api_key_validating"));
          try {
            var testResponse = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + encodeURIComponent(newKey), {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ contents: [{ parts: [{ text: "Hi" }] }] })
            });
            if (testResponse.status === 400 || testResponse.status === 403) {
              setStatus("settings-status", t("status_api_key_invalid"), true);
              return;
            }
            if (testResponse.status === 429) {
              // Key is valid but rate-limited — save it anyway
              setStatus("settings-status", t("status_api_key_rate_limited"), false);
            }
          } catch (e) {
            console.error("[MaiTribe] API key validation failed:", e);
          }
        }

        // Save API key to localStorage before DB update (so it's saved even if DB fails)
        var config = {
          ...appState.config,
          geminiApiKey: newKey,
          vapidPublicKey: getEl("settings-vapid").value.trim()
        };
        saveConfig(config);

        var updates = {
          name: getEl("settings-name").value.trim() || null,
          display_name: getEl("settings-name").value.trim() || null,
          language: getEl("settings-language").value,
          timezone: getEl("settings-timezone").value.trim() || detectTimezone(),
          morning_reminder_time: getEl("settings-morning-time").value || "07:00",
          morning_reminder_enabled: getEl("settings-morning-enabled").checked,
          mindful_reminders_enabled: getEl("settings-mindful-enabled").checked,
          mindful_reminder_count: Number(getEl("settings-mindful-count").value || 2),
          event_followup_enabled: getEl("settings-event-enabled").checked,
          last_active_at: new Date().toISOString()
        };

        var { error } = await updateUsersSafe(appState.currentUser.id, updates);
        if (error) {
          setStatus("settings-status", error.message || t("status_could_not_save_settings"), true);
          return;
        }

        await loadProfile();
        applyI18n();
        await loadHomeScreen();

        if (newKey && newKey !== oldKey) {
          setStatus("settings-status", t("status_api_key_valid"));
        } else {
          setStatus("settings-status", t("status_saved"));
        }
      }

      async function initChat() {
        if (!appState.currentUser) return;
        const nowMinus30 = new Date(Date.now() - 30 * 60 * 1000).toISOString();

        const { data: activeConversation } = await appState.supabase
          .from("conversations")
          .select("*")
          .eq("user_id", appState.currentUser.id)
          .eq("is_active", true)
          .gte("updated_at", nowMinus30)
          .order("updated_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        if (activeConversation) {
          appState.currentConversationId = activeConversation.id;
          await loadMessages(activeConversation.id);
          return;
        }

        const { data: newConversation, error } = await appState.supabase
          .from("conversations")
          .insert({ user_id: appState.currentUser.id, is_active: true })
          .select("*")
          .single();

        if (error || !newConversation) {
          appendMessageBubble("assistant", t("err_api"));
          return;
        }

        appState.currentConversationId = newConversation.id;
        clearMessages();

        var opening = getFallbackOpening();
        await saveMessage("assistant", opening, "text");
        appendMessageBubble("assistant", opening);
      }

      async function loadMessages(conversationId) {
        clearMessages();
        const { data } = await appState.supabase
          .from("messages")
          .select("role, content")
          .eq("conversation_id", conversationId)
          .order("created_at", { ascending: true })
          .limit(200);

        if (data && data.length) {
          data.forEach((msg) => appendMessageBubble(msg.role, msg.content));
        } else {
          appendMessageBubble("assistant", getFallbackOpening());
        }
      }

      async function saveMessage(role, content, inputType) {
        if (!appState.currentConversationId) return;

        await appState.supabase.from("messages").insert({
          conversation_id: appState.currentConversationId,
          user_id: appState.currentUser.id,
          role: role,
          content: content,
          input_type: inputType || "text"
        });

        await appState.supabase
          .from("conversations")
          .update({ updated_at: new Date().toISOString() })
          .eq("id", appState.currentConversationId);
      }

      function clearMessages() {
        const area = getEl("chat-messages");
        area.innerHTML = '<div id="chat-empty-state" class="chat-empty-state">' + t("chat_empty").replace(/\n/g, "<br>") + '</div>';
      }

      function appendMessageBubble(role, text, isTyping) {
        const area = getEl("chat-messages");
        const emptyState = getEl("chat-empty-state");
        if (emptyState) emptyState.remove();

        const wrap = document.createElement("div");
        wrap.className = "bubble-wrap" + (role === "user" ? " user" : "");

        if (role === "assistant") {
          wrap.innerHTML = '<div class="bubble-avatar">m</div>';
        }

        const bubble = document.createElement("div");
        bubble.className = "bubble " + (role === "assistant" ? "assistant" : "user");

        if (isTyping) {
          bubble.innerHTML = '<span class="typing"><i></i><i></i><i></i></span>';
        } else {
          bubble.textContent = text;
        }

        wrap.appendChild(bubble);
        area.appendChild(wrap);
        area.scrollTop = area.scrollHeight;
        return bubble;
      }

      async function sendMessage(userText) {
        if (!userText.trim() || !appState.currentConversationId) return;

        appendMessageBubble("user", userText.trim());
        await saveMessage("user", userText.trim(), appState.lastInputWasVoice ? "voice" : "text");

        var typingBubble = appendMessageBubble("assistant", "", true);

        try {
          var context = await getUserContext(appState.currentUser.id);

          var { data: historyData } = await appState.supabase
            .from("messages")
            .select("role, content")
            .eq("conversation_id", appState.currentConversationId)
            .order("created_at", { ascending: true })
            .limit(20);

          var history = historyData || [];
          var responseResult = await callGeminiChat(context, history, userText.trim());
          if (typingBubble.parentNode) typingBubble.parentNode.remove(); else typingBubble.remove();

          if (!responseResult.text) {
            var errCode = responseResult.error && responseResult.error.error;
            var errStatus = responseResult.error && responseResult.error.status;
            appendMessageBubble("assistant", softGeminiErrorMessage(errCode, errStatus));
            return;
          }
          appendMessageBubble("assistant", responseResult.text);
          await saveMessage("assistant", responseResult.text, "text");

          extractEventsFromMessage(userText.trim()).catch(function(err) { console.error("[MaiTribe] extractEvents error:", err); });
        } catch (err) {
          if (typingBubble.parentNode) typingBubble.parentNode.remove(); else typingBubble.remove();
          console.error("[MaiTribe] sendMessage error:", err);
          appendMessageBubble("assistant", t("err_api"));
        }
      }

      async function getUserContext(userId) {
        const today = new Date().toISOString().slice(0, 10);

        var settled = await Promise.allSettled([
          appState.supabase.from("users").select("*").eq("id", userId).single(),
          appState.supabase.from("identities").select("*").eq("user_id", userId).eq("is_active", true).order("created_at", { ascending: false }).limit(1).maybeSingle(),
          appState.supabase.from("checkins").select("body,mind,soul,energy,note,created_at").eq("user_id", userId).order("created_at", { ascending: false }).limit(3),
          appState.supabase.from("events").select("title,description,event_time").eq("user_id", userId).eq("status", "upcoming").gt("event_time", new Date().toISOString()).order("event_time", { ascending: true }).limit(5),
          appState.supabase.from("conversations").select("topics,summary").eq("user_id", userId).order("created_at", { ascending: false }).limit(5),
          appState.supabase.from("astro_transits").select("daily_insight,hd_daily_gate,hd_gate_description").eq("user_id", userId).eq("transit_date", today).limit(1).maybeSingle(),
          appState.supabase.from("memories").select("content, category, importance, created_at").eq("user_id", userId).order("importance", { ascending: false }).order("created_at", { ascending: false }).limit(15)
        ]);

        function val(i) {
          if (settled[i].status === "rejected") {
            console.error("[MaiTribe] getUserContext query " + i + " failed:", settled[i].reason);
            return { data: null };
          }
          var r = settled[i].value;
          if (r && r.error) console.warn("[MaiTribe] getUserContext query " + i + " error:", r.error.message);
          return r || { data: null };
        }

        return {
          user: val(0).data || appState.profile || {},
          identity: val(1).data || null,
          recent_checkins: val(2).data || [],
          upcoming_events: val(3).data || [],
          recent_topics: val(4).data || [],
          today_transits: val(5).data || null,
          memories: val(6).data || []
        };
      }

      function buildSystemPrompt(context) {
        const user = context.user || {};
        const identity = context.identity || {};
        const memories = context.memories || [];
        const langCode = user.language || (appState.profile && appState.profile.language) || getCurrentLanguage() || "en";
        var userName = user.display_name || user.name || "";

        var prompt;
        if (langCode === "de") {
          prompt = `Du bist Mai.

Du bist eine kluge, warme Freundin. Du bist kein Coach, kein Therapeut, keine Wellness-App, kein Chatbot. Du bist einfach jemand der zuh\u00F6rt, versteht, und ehrlich antwortet.

WIE DU SPRICHST:
- Kurze S\u00E4tze. Nat\u00FCrliche Sprache. So wie eine echte Person schreibt \u2014 nicht wie eine App.
- Du sagst "Ugh, das nervt" statt "Das klingt herausfordernd".
- Du sagst "Nice!" statt "Das ist wunderbar, dass du diesen Schritt gemacht hast".
- Du sagst "Okay, was h\u00E4lt dich ab?" statt "Was glaubst du, was dich davon abh\u00E4lt, den n\u00E4chsten Schritt zu machen?"
- Wenn jemand gut drauf ist, freu dich mit. Kurz. Echt. Keine Analyse warum es gut ist.
- Wenn jemand schlecht drauf ist, zeig dass du es verstehst. Dann hilf. Frag nicht erstmal ob die Person Hilfe will \u2014 wenn sie dir schreibt, will sie Hilfe.
- Du benutzt die gleichen W\u00F6rter wie die Person. Wenn sie "krass" sagt, sagst du auch "krass". Wenn sie "heftig" sagt, sagst du "heftig". Nicht deine eigene Wellness-Sprache dr\u00FCberst\u00FClpen.

WAS DU WEISST:
- Du hast echtes Wissen aus Psychologie, Neurowissenschaft, Ern\u00E4hrung, Schlafforschung, Produktivit\u00E4t, Pers\u00F6nlichkeitsentwicklung, und Philosophie.
- Du benutzt dieses Wissen wie eine kluge Freundin: beil\u00E4ufig, konkret, \u00FCberraschend. Nicht wie eine Dozentin.
- Wenn jemand gestresst ist, sagst du nicht "Atme tief ein". Du sagst: "Trink erstmal ein Glas Wasser. Klingt banal, aber Dehydration und Stress f\u00FChlen sich fast identisch an."
- Wenn jemand nicht einschlafen kann, sagst du nicht "Mach ein Abendritual". Du sagst: "Versuch mal Cognitive Shuffle \u2014 denk dir komplett zuf\u00E4llige Bilder aus: Katze, L\u00F6ffel, Wolke, Fahrrad. Klingt absurd, unterbricht aber die Gedankenschleife."
- Wenn jemand sich nicht aufraffen kann, sagst du nicht "Was ist der kleinste Schritt?". Du sagst: "Stell dir einen Timer auf 5 Minuten. Nur 5. Motivation kommt meistens erst NACH dem Anfangen, nicht davor."
- Du gibst pro Antwort EINEN konkreten Tipp. Nicht drei. Nicht f\u00FCnf. Einen.

WAS DU NICHT TUST:
- Du sagst niemals "Das klingt herausfordernd" oder "Viele Menschen erleben das" oder "Nimm dir einen Moment" oder "Sp\u00FCre in dich hinein" oder "Atme tief ein" (als alleinigen Tipp).
- Du fragst nicht "M\u00F6chtest du dar\u00FCber reden?" \u2014 wenn die Person dir schreibt, redet sie bereits mit dir.
- Du machst keine Listen. Keine Aufz\u00E4hlungen. Keine nummerierten Schritte. Du redest in S\u00E4tzen.
- Du analysierst nicht warum etwas gut oder schlecht ist. Du reagierst einfach menschlich.
- Du sagst nicht "Ich bin f\u00FCr dich da" \u2014 das ist eine leere Phrase. Zeig es stattdessen indem du wirklich hilfst.
- Du fragst nie mehr als eine Frage pro Nachricht.
- Du \u00FCbersch\u00FCttest niemanden mit Mitgef\u00FChl. Einmal anerkennen reicht. Dann vorw\u00E4rts.

WANN DU TIPPS GIBST UND WANN NICHT:
- Nicht jede Nachricht braucht einen Tipp. Manchmal will die Person einfach geh\u00F6rt werden.
- Wenn jemand sagt "ich bin gereizt und verstehe nicht warum" \u2014 das ist kein Tipp-Moment. Das ist ein Moment zum Nachfragen: "Energielos und gereizt ohne Grund \u2014 hast du letzte Nacht schlecht geschlafen?" Erst verstehen, dann helfen.
- Wenn jemand ein konkretes Problem nennt ("ich kann nicht einschlafen", "ich muss einen Post machen aber kann mich nicht aufraffen") \u2014 DANN gib einen Tipp.
- Wenn jemand vage Gef\u00FChle beschreibt ("f\u00FChle mich komisch", "wei\u00DF nicht was los ist") \u2014 frag nach. Hilf der Person rauszufinden was eigentlich los ist.
- Wenn dein letzter Tipp nicht geholfen hat, gib NICHT sofort den n\u00E4chsten. Frag erstmal: "Okay, vergiss das. Was glaubst du woran es liegt?"
- Maximal 2 Tipps pro Gespr\u00E4ch. Danach bist du im Zuh\u00F6r-Modus, es sei denn die Person fragt explizit nach mehr.

WIEDERHOLUNGEN VERMEIDEN:
- Lies den GESAMTEN bisherigen Gespr\u00E4chsverlauf bevor du antwortest.
- Wiederhole NIEMALS einen Tipp den du in diesem Gespr\u00E4ch schon gegeben hast. Wenn du "Trink Wasser" schon gesagt hast, sag es nicht nochmal.
- Starte nicht jede Antwort gleich. Wenn du beim letzten Mal mit "Ugh" angefangen hast, fang diesmal anders an. Variiere: manchmal eine Frage, manchmal direkt ins Thema, manchmal Mitgef\u00FChl, manchmal ein Tipp.
- Wenn du merkst dass du ins gleiche Muster f\u00E4llst (Anerkennen \u2192 Tipp \u2192 Erkl\u00E4rung), brich das Muster. Stell eine Frage. Oder sag einfach "Das klingt nach einem harten Tag" und warte.

KRISEN:
- Wenn jemand Suizidgedanken oder Selbstverletzung andeutet: Nimm es ernst. Sag direkt: "Hey, das klingt ernst. Bitte ruf die Telefonseelsorge an: 0800 111 0 111 (kostenlos, 24/7). Die k\u00F6nnen helfen."
- Du bist kein Ersatz f\u00FCr professionelle Hilfe. Wenn etwas \u00FCber deine M\u00F6glichkeiten geht, sag das ehrlich.

Antworte IMMER auf Deutsch.`;
        } else {
          prompt = `You are Mai.

You are a smart, warm friend. Not a coach, not a therapist, not a wellness app, not a chatbot. You\u2019re just someone who listens, understands, and gives honest answers.

HOW YOU TALK:
- Short sentences. Natural language. Like a real person texts \u2014 not like an app.
- You say "Ugh, that sucks" not "That sounds challenging".
- You say "Nice!" not "That\u2019s wonderful that you took that step".
- You say "Okay, what\u2019s stopping you?" not "What do you think might be holding you back from taking the next step?"
- When someone\u2019s in a good mood, be happy with them. Short. Real. Don\u2019t analyze why it\u2019s good.
- When someone\u2019s struggling, show you get it. Then help. Don\u2019t ask if they want help first \u2014 if they\u2019re writing to you, they want help.
- Use the same words the person uses. If they say "crazy", you say "crazy". If they say "rough", you say "rough". Don\u2019t overlay your own wellness vocabulary.

WHAT YOU KNOW:
- You have real knowledge from psychology, neuroscience, nutrition, sleep science, productivity, personal development, and philosophy.
- You use this knowledge like a smart friend: casually, concretely, surprisingly. Not like a lecturer.
- When someone\u2019s stressed, don\u2019t say "take a deep breath". Say: "Drink a glass of water first. Sounds basic, but dehydration and stress feel almost identical."
- When someone can\u2019t sleep, don\u2019t say "create an evening routine". Say: "Try Cognitive Shuffle \u2014 think of completely random images: cat, spoon, cloud, bicycle. Sounds weird, but it breaks the thought loop."
- When someone can\u2019t get started, don\u2019t say "what\u2019s the smallest step?". Say: "Set a 5-minute timer. Just 5. Motivation usually comes AFTER starting, not before."
- Give ONE concrete tip per response. Not three. Not five. One.

WHAT YOU DON\u2019T DO:
- Never say "That sounds challenging" or "Many people experience this" or "Take a moment" or "Tune into your body" or "Take a deep breath" (as standalone advice).
- Don\u2019t ask "Would you like to talk about it?" \u2014 if the person is writing to you, they\u2019re already talking to you.
- Don\u2019t make lists. No bullet points. No numbered steps. You talk in sentences.
- Don\u2019t analyze why something is good or bad. Just react like a human.
- Don\u2019t say "I\u2019m here for you" \u2014 that\u2019s an empty phrase. Show it by actually helping.
- Never ask more than one question per message.
- Don\u2019t drown someone in empathy. Acknowledge once. Then move forward.

WHEN TO GIVE TIPS AND WHEN NOT:
- Not every message needs a tip. Sometimes the person just wants to be heard.
- When someone says "I\u2019m irritated and don\u2019t know why" \u2014 that\u2019s not a tip moment. That\u2019s a moment to ask: "Drained and irritated for no reason \u2014 did you sleep badly last night?" Understand first, then help.
- When someone names a concrete problem ("I can\u2019t fall asleep", "I need to write a post but can\u2019t get started") \u2014 THEN give a tip.
- When someone describes vague feelings ("feeling weird", "don\u2019t know what\u2019s going on") \u2014 ask questions. Help the person figure out what\u2019s actually happening.
- When your last tip didn\u2019t help, DON\u2019T immediately give the next one. Ask first: "Okay, forget that. What do you think it is?"
- Maximum 2 tips per conversation. After that you\u2019re in listening mode, unless the person explicitly asks for more.

AVOIDING REPETITION:
- Read the ENTIRE conversation history before responding.
- NEVER repeat a tip you already gave in this conversation. If you said "drink water" already, don\u2019t say it again.
- Don\u2019t start every response the same way. If you started with "Ugh" last time, start differently this time. Vary: sometimes a question, sometimes straight into the topic, sometimes empathy, sometimes a tip.
- If you notice you\u2019re falling into the same pattern (acknowledge \u2192 tip \u2192 explanation), break it. Ask a question. Or just say "That sounds like a rough day" and wait.

CRISIS:
- If someone hints at suicidal thoughts or self-harm: Take it seriously. Say directly: "Hey, that sounds serious. Please call 988 (Suicide & Crisis Lifeline, free, 24/7). They can help."
- You\u2019re not a replacement for professional help. When something\u2019s beyond your abilities, say so honestly.

ALWAYS respond in English.`;
        }

        // --- Identity context ---
        if (identity && identity.full_text) {
          prompt += `\n\nIDENTIT\u00C4T / IDENTITY: "${identity.full_text}"`;
          if (identity.sentences && identity.sentences.length) {
            prompt += `\nCore sentences: ${JSON.stringify(identity.sentences)}`;
          }
        } else if (identity && identity.one_liner) {
          prompt += `\nIdentity: ${identity.one_liner}`;
        }

        // --- Memory context ---
        if (memories.length) {
          var memoryList = memories.map(function(m) { return "- " + m.content; }).join("\n");
          if (langCode === "de") {
            prompt += `\n\nERINNERUNGEN:\nDu wei\u00DFt folgendes \u00FCber diese Person aus fr\u00FCheren Gespr\u00E4chen. Das ist normal \u2014 du erinnerst dich halt.\n\n${memoryList}\n\nRegeln:\n- Erw\u00E4hne Memories NIE in der Begr\u00FC\u00DFung.\n- Pro Antwort maximal EIN Bezug auf etwas Fr\u00FCheres, und nur wenn es wirklich zum Thema passt.\n- Wenn es nicht passt, ignoriere die Memories komplett.\n- Was der User JETZT sagt hat IMMER Vorrang.`;
          } else {
            prompt += `\n\nMEMORIES:\nYou know the following about this person from past conversations. That\u2019s normal \u2014 you just remember.\n\n${memoryList}\n\nRules:\n- NEVER mention memories in greetings.\n- Maximum ONE reference to something earlier per response, and only when it truly fits the topic.\n- When it doesn\u2019t fit, ignore the memories completely.\n- What the user says NOW always takes precedence.`;
          }
        }

        // --- Astro/HD context ---
        var astroCtx = buildAstroContext(user);
        if (astroCtx) prompt += astroCtx;

        prompt += `\n\nName: ${userName || "friend"}`;
        return prompt;
      }

      async function callGeminiChat(context, history, userMessage) {
        const systemPrompt = buildSystemPrompt(context);
        const payloadHistory = (history || []).map((msg) => ({
          role: msg.role === "assistant" ? "model" : "user",
          parts: [{ text: msg.content }]
        }));

        payloadHistory.push({ role: "user", parts: [{ text: userMessage }] });

        const data = await callAI({
          systemPrompt: systemPrompt,
          contents: payloadHistory,
          maxOutputTokens: 2048,
          timeout: 30000,
          temperature: 0.8,
          topP: 0.9
        });

        return parseGeminiResult(data);
      }

      async function callGeminiForCheckin(promptText) {
        var langCode = getCurrentLanguage();
        var sysPrompt = langCode === "de"
          ? "Du bist Mai \u2014 eine kluge, warme Freundin. Kurz, echt, direkt. Keine Listen, kein Coaching-Ton, keine Emojis. 2-3 S\u00E4tze max. Antworte auf Deutsch."
          : "You are Mai \u2014 a smart, warm friend. Short, real, direct. No lists, no coaching tone, no emojis. 2-3 sentences max.";
        const data = await callAI({
          systemPrompt: sysPrompt,
          contents: [{ role: "user", parts: [{ text: promptText }] }],
          maxOutputTokens: 512,
          temperature: 0.75,
          topP: 0.9
        });

        return parseGeminiResult(data);
      }

      async function callGeminiRaw(promptText, maxOutputTokens) {
        var langCode = getCurrentLanguage();
        var sysPrompt = langCode === "de"
          ? "Du bist Mai \u2014 ruhige, emotional intelligente Begleiterin. Kurz. Warm. Geerdet. Keine Listen. Keine Emojis."
          : "You are Mai \u2014 calm, emotionally intelligent companion. Short. Warm. Grounded. No lists. No emojis.";
        console.log("[MaiTribe] callGeminiRaw called, prompt length:", (promptText || "").length);
        try {
          const data = await callAI({
            systemPrompt: sysPrompt,
            contents: [{ role: "user", parts: [{ text: promptText }] }],
            maxOutputTokens: maxOutputTokens || 1024,
            temperature: 0.75,
            topP: 0.9
          });
          console.log("[MaiTribe] Gemini response received");
          return parseGeminiResult(data);
        } catch (error) {
          console.error("[MaiTribe] Gemini API error:", error);
          return { text: null, error: { error: "network_error", status: 0 } };
        }
      }

      async function callAI(options, retryCount) {
        if (retryCount == null) retryCount = 0;
        var key = appState.config.geminiApiKey;
        if (!key) return { error: "no_key" };

        var model = options.model || (retryCount === 0 ? "gemini-2.5-flash" : "gemini-2.5-flash-lite");
        console.log("[MaiTribe] callAI model:", model, "retry:", retryCount);
        var apiUrl = "https://generativelanguage.googleapis.com/v1beta/models/" + model + ":generateContent?key=" + encodeURIComponent(key);
        var timeout = options.timeout || 20000;

        var controller = new AbortController();
        var timer = setTimeout(function() { controller.abort(); }, timeout);

        try {
          var response = await fetch(apiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            signal: controller.signal,
            body: JSON.stringify({
              system_instruction: { parts: [{ text: options.systemPrompt || "" }] },
              contents: options.contents || [],
              generationConfig: {
                temperature: options.temperature == null ? 0.8 : options.temperature,
                topP: options.topP == null ? 0.9 : options.topP,
                maxOutputTokens: options.maxOutputTokens == null ? 2048 : options.maxOutputTokens
              }
            })
          });
          clearTimeout(timer);

          if (response.status === 429 && retryCount < 2) {
            var retryAfter = 15 + (retryCount * 15);
            console.log("Gemini " + model + " rate limited, retrying in " + retryAfter + "s...");
            await new Promise(function(resolve) { setTimeout(resolve, retryAfter * 1000); });
            return callAI(options, retryCount + 1);
          }

          if (!response.ok) {
            var errorText = await response.text();
            console.error("Gemini error (" + model + "):", errorText);
            return { error: "api_error", status: response.status };
          }

          return await response.json();
        } catch (error) {
          clearTimeout(timer);
          if (error.name === "AbortError") {
            console.error("Gemini timeout (" + model + ") after " + timeout + "ms");
            return { error: "timeout", status: 408 };
          }
          console.error("Gemini request failed (" + model + ")", error);
          return { error: "network_error" };
        }
      }

      function parseGeminiResult(data) {
        if (!data) {
          return { text: null, error: { error: "api_error", status: 0 } };
        }
        if (data.error) {
          return { text: null, error: { error: data.error, status: data.status || 0 } };
        }
        var text = extractGeminiText(data);
        if (!text) {
          return { text: null, error: { error: "empty", status: 0 } };
        }
        return { text: text, error: null };
      }

      function extractGeminiText(data) {
        if (!data || !data.candidates || !data.candidates.length) return null;
        const parts = data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts;
        if (!parts || !parts.length) return null;
        return parts.map((part) => part.text || "").join("\n").trim() || null;
      }

      // ── Mai Memory System ──────────────────────────────────────

      var _memoryExtractionDone = {};
      var _memoryExtractionPending = false;

      function isDuplicateMemory(newContent, existingMemories) {
        var newWords = newContent.toLowerCase().split(/\s+/).filter(function(w) { return w.length > 3; });
        if (!newWords.length) return null;
        for (var i = 0; i < existingMemories.length; i++) {
          var existing = existingMemories[i];
          var existingWords = existing.content.toLowerCase().split(/\s+/).filter(function(w) { return w.length > 3; });
          if (!existingWords.length) continue;
          var overlap = 0;
          for (var j = 0; j < newWords.length; j++) {
            if (existingWords.indexOf(newWords[j]) !== -1) overlap++;
          }
          var ratio = overlap / Math.max(newWords.length, 1);
          if (ratio > 0.5) return existing.id;
        }
        return null;
      }

      async function enforceMemoryLimit(userId) {
        try {
          var countResult = await appState.supabase
            .from("memories")
            .select("id", { count: "exact", head: true })
            .eq("user_id", userId);
          var total = countResult.count || 0;
          if (total <= 100) return;
          var excess = total - 100;
          var oldest = await appState.supabase
            .from("memories")
            .select("id")
            .eq("user_id", userId)
            .order("importance", { ascending: true })
            .order("created_at", { ascending: true })
            .limit(excess);
          if (oldest.data && oldest.data.length) {
            var ids = oldest.data.map(function(m) { return m.id; });
            await appState.supabase.from("memories").delete().in("id", ids);
            console.log("[MaiTribe] Enforced memory limit, removed", ids.length, "old memories");
          }
        } catch (err) {
          console.warn("[MaiTribe] enforceMemoryLimit error:", err);
        }
      }

      async function extractAndSaveMemories(conversationId, userId, langCode) {
        if (!conversationId || !userId) return;
        if (_memoryExtractionDone[conversationId]) return;
        _memoryExtractionDone[conversationId] = true;

        try {
          var msgResult = await appState.supabase
            .from("messages")
            .select("role, content")
            .eq("conversation_id", conversationId)
            .order("created_at", { ascending: true });

          if (!msgResult.data || msgResult.data.length < 4) return;
          var userMsgCount = msgResult.data.filter(function(m) { return m.role === "user"; }).length;
          if (userMsgCount < 2) return;

          var conversationText = msgResult.data.map(function(m) {
            return (m.role === "user" ? "User" : "Mai") + ": " + m.content;
          }).join("\n");

          var lang = langCode || getCurrentLanguage() || "en";
          var extractionSystemPrompt;
          if (lang === "de") {
            extractionSystemPrompt = "Du bist ein Memory-Extraktionssystem. Analysiere das folgende Gespräch und extrahiere wichtige Fakten, Vorlieben, Emotionen und persönliche Details über den User.\n\nAntworte NUR mit einem JSON-Array. Jedes Element hat:\n- \"content\": der Memory-Text (kurz, prägnant, 1 Satz)\n- \"category\": eine von [\"personal\", \"preference\", \"emotion\", \"goal\", \"health\", \"relationship\", \"work\", \"spiritual\", \"general\"]\n- \"importance\": 1-10 (wie wichtig ist dieses Detail für zukünftige Gespräche?)\n\nRegeln:\n- Maximal 5 Memories pro Gespräch\n- Nur wirklich bedeutsame Informationen extrahieren\n- Keine trivialen Smalltalk-Details\n- Formuliere Memories aus der Perspektive über den User, z.B. \"Hat einen Hund namens Bello\" nicht \"User hat einen Hund\"\n- Antworte NUR mit dem JSON-Array, kein anderer Text";
          } else {
            extractionSystemPrompt = "You are a memory extraction system. Analyze the following conversation and extract important facts, preferences, emotions, and personal details about the user.\n\nRespond ONLY with a JSON array. Each element has:\n- \"content\": the memory text (short, concise, 1 sentence)\n- \"category\": one of [\"personal\", \"preference\", \"emotion\", \"goal\", \"health\", \"relationship\", \"work\", \"spiritual\", \"general\"]\n- \"importance\": 1-10 (how important is this detail for future conversations?)\n\nRules:\n- Maximum 5 memories per conversation\n- Only extract truly meaningful information\n- No trivial small-talk details\n- Phrase memories from a perspective about the user, e.g. \"Has a dog named Bello\" not \"User has a dog\"\n- Respond ONLY with the JSON array, no other text";
          }

          var data = await callAI({
            systemPrompt: extractionSystemPrompt,
            contents: [{ role: "user", parts: [{ text: conversationText }] }],
            maxOutputTokens: 512,
            temperature: 0.3,
            topP: 0.9
          });

          var rawText = extractGeminiText(data);
          if (!rawText) {
            console.warn("[MaiTribe] Memory extraction returned empty");
            return;
          }

          var jsonMatch = rawText.match(/\[[\s\S]*\]/);
          if (!jsonMatch) {
            console.warn("[MaiTribe] Memory extraction: no JSON array found in response");
            return;
          }

          var memories;
          try {
            memories = JSON.parse(jsonMatch[0]);
          } catch (parseErr) {
            console.warn("[MaiTribe] Memory extraction: JSON parse failed:", parseErr);
            return;
          }

          if (!Array.isArray(memories) || !memories.length) return;

          var sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
          var recentResult = await appState.supabase
            .from("memories")
            .select("id, content, category")
            .eq("user_id", userId)
            .gte("created_at", sevenDaysAgo);
          var recentMemories = (recentResult.data || []);

          var savedCount = 0;
          for (var i = 0; i < Math.min(memories.length, 5); i++) {
            var mem = memories[i];
            if (!mem.content || typeof mem.content !== "string") continue;
            var content = mem.content.trim();
            if (!content) continue;
            var category = mem.category || "general";
            var importance = Math.max(1, Math.min(10, parseInt(mem.importance) || 5));

            var sameCategoryRecent = recentMemories.filter(function(r) { return r.category === category; });
            var duplicateId = isDuplicateMemory(content, sameCategoryRecent);

            if (duplicateId) {
              await appState.supabase
                .from("memories")
                .update({ content: content, importance: importance, updated_at: new Date().toISOString() })
                .eq("id", duplicateId);
              console.log("[MaiTribe] Updated existing memory:", content.substring(0, 50));
            } else {
              await appState.supabase
                .from("memories")
                .insert({
                  user_id: userId,
                  conversation_id: conversationId,
                  content: content,
                  category: category,
                  importance: importance
                });
              savedCount++;
            }
          }

          await enforceMemoryLimit(userId);
          console.log("[MaiTribe] Extracted " + savedCount + " new memories from conversation " + conversationId);
        } catch (err) {
          console.error("[MaiTribe] extractAndSaveMemories error:", err);
        }
      }

      // ── End Mai Memory System ──────────────────────────────────

      async function extractEventsFromMessage(text) {
        const patterns = /\b(tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday|next week|at\s+\d{1,2}(:\d{2})?\s*(am|pm)?)\b/i;
        if (!patterns.test(text)) return;

        const profile = appState.profile || {};
        const prompt = "Extract any scheduled event from this message. Return JSON only.\\n" +
          "Format: {\"title\":\"...\",\"datetime\":\"ISO8601\",\"found\":true/false}\\n" +
          "If no event found, return {\"found\":false}.\\n" +
          "Current datetime: " + new Date().toISOString() + "\\n" +
          "User timezone: " + (profile.timezone || "UTC") + "\\n" +
          "Message: \"" + text.replace(/"/g, "\\\\\"") + "\"";

        const rawResult = await callGeminiRaw(prompt, 180);
        if (!rawResult.text) return;

        const event = safeJsonParse(rawResult.text, { found: false });
        if (!event.found || !event.title || !event.datetime) return;

        await appState.supabase.from("events").insert({
          user_id: appState.currentUser.id,
          title: event.title,
          event_time: event.datetime,
          source: "chat"
        });
      }

      async function submitCheckinFromScreen(prefix) {
        const body = Number(getEl(prefix + "-body").value);
        const mind = Number(getEl(prefix + "-mind").value);
        const soul = Number(getEl(prefix + "-soul").value);
        const energy = Number(getEl(prefix + "-energy").value);
        const noteId = prefix === "onboard" ? "onboard-note" : "checkin-note";
        const note = getEl(noteId).value.trim();

        if (prefix === "onboard") {
          appState.onboarding.checkin = { body, mind, soul, energy, note };
          setStatus("onboard-checkin-status", t("status_reflecting"));
        } else {
          setStatus("checkin-status", t("status_saving_checkin"));
        }

        if (prefix !== "onboard") {
          const { data: inserted, error } = await appState.supabase.from("checkins").insert({
            user_id: appState.currentUser.id,
            body: body,
            mind: mind,
            soul: soul,
            energy: energy,
            note: note || null
          }).select("*").single();

          if (error || !inserted) {
            setStatus("checkin-status", t("status_could_not_save_checkin"), true);
            return;
          }

          setStatus("checkin-status", t("status_saved"));

          var safeReflection;
          try {
            var reflectionPromise = (async function() {
              var ctx = await getUserContext(appState.currentUser.id);
              var prompt = buildCheckinPrompt({ body: body, mind: mind, soul: soul, energy: energy, note: note, context: ctx });
              return await callGeminiForCheckin(prompt);
            })();

            var timeoutPromise = new Promise(function(_, reject) {
              setTimeout(function() { reject(new Error("timeout")); }, 15000);
            });

            var reflectionResult = await Promise.race([reflectionPromise, timeoutPromise]);
            safeReflection = reflectionResult.text || buildLocalCheckinFallback({ body: body, mind: mind, soul: soul, energy: energy, note: note, context: {} });
          } catch (e) {
            console.error("[MaiTribe] checkin reflection error:", e);
            safeReflection = buildLocalCheckinFallback({ body: body, mind: mind, soul: soul, energy: energy, note: note, context: {} });
          }

          if (safeReflection) {
            await appState.supabase.from("checkins").update({ mai_response: safeReflection }).eq("id", inserted.id);
            var responseNode = getEl("checkin-response");
            responseNode.textContent = safeReflection;
            responseNode.classList.remove("hidden");
          }

          await loadHomeScreen();
          return;
        }

        const context = {
          user: { language: getEl("onboard-language").value },
          identity: null,
          recent_checkins: []
        };
        try {
          const prompt = buildCheckinPrompt({ body, mind, soul, energy, note, context });
          const reflectionResult = await callGeminiForCheckin(prompt);
          appState.onboarding.checkinResponse = reflectionResult.text || buildLocalCheckinFallback({ body, mind, soul, energy, note, context });
        } catch (e) {
          console.error("[MaiTribe] onboarding checkin reflection error:", e);
          appState.onboarding.checkinResponse = buildLocalCheckinFallback({ body, mind, soul, energy, note, context });
        }

        getEl("onboard-checkin-response").textContent = appState.onboarding.checkinResponse;
        getEl("onboard-checkin-response").classList.remove("hidden");
        if (appState.onboarding.checkinResponse) {
          setStatus("onboard-checkin-status", t("status_reflection_ready"));
        } else {
          setStatus("onboard-checkin-status", t("status_checkin_ai_unavailable"), false);
        }
      }

      function buildCheckinPrompt(args) {
        const langCode = args.context && args.context.user && args.context.user.language ? args.context.user.language : "en";
        const identityObj = args.context && args.context.identity ? args.context.identity : {};

        var base;
        if (langCode === "de") {
          base = `Der User hat gerade einen Check-in gemacht. K\u00F6rper: ${args.body}/10, Geist: ${args.mind}/10, Seele: ${args.soul}/10, Energie: ${args.energy}/10.
${args.note ? `Notiz: "${args.note}"` : ""}

Reagiere kurz und echt. 2-3 S\u00E4tze max.
- Wenn alles gut ist: Freu dich mit. Kurz.
- Wenn was niedrig ist: Benenn es direkt und gib EINEN konkreten Tipp.
- Wenn Energie unter 2: Sag dass es okay ist wenig zu machen heute. Kein Druck.
Keine Listen. Keine Fragen. Einfach eine warme, ehrliche Reaktion.

Antworte auf Deutsch.`;
        } else {
          base = `The user just did a check-in. Body: ${args.body}/10, Mind: ${args.mind}/10, Soul: ${args.soul}/10, Energy: ${args.energy}/10.
${args.note ? `Note: "${args.note}"` : ""}

React briefly and genuinely. 2-3 sentences max.
- If everything's good: Be happy with them. Short.
- If something's low: Name it directly and give ONE concrete tip.
- If energy is below 2: Say it's okay to do less today. No pressure.
No lists. No questions. Just a warm, honest reaction.`;
        }

        if (identityObj && identityObj.full_text) {
          base += `\nIdentity: "${identityObj.full_text}"`;
        } else if (identityObj && identityObj.one_liner) {
          base += `\nIdentity: ${identityObj.one_liner}`;
        }

        return base;
      }

      async function saveIdentityEdit() {
        const newText = getEl("identity-edit-text").value.trim();
        if (!newText) {
          setStatus("identity-edit-status", t("status_identity_empty"), true);
          return;
        }

        const userId = appState.currentUser.id;
        console.log("[MaiTribe] saveIdentityEdit: userId =", userId, "textLength =", newText.length);

        const sentences = splitIdentitySentences(newText);
        var { data: existingIdentity, error: existingError } = await appState.supabase
          .from("identities")
          .select("id")
          .eq("user_id", userId)
          .eq("is_active", true)
          .order("created_at", { ascending: false })
          .limit(1)
          .maybeSingle();
        if (existingError) {
          console.warn("[MaiTribe] identity lookup error:", existingError);
        }

        var result;
        if (existingIdentity && existingIdentity.id) {
          console.log("[MaiTribe] updating active identity id:", existingIdentity.id);
          result = await appState.supabase
            .from("identities")
            .update({
              full_text: newText,
              one_liner: sentences[0] || newText,
              sentences: sentences,
              is_active: true
            })
            .eq("id", existingIdentity.id)
            .eq("user_id", userId)
            .select();
        } else {
          const insertPayload = {
            user_id: userId,
            full_text: newText,
            one_liner: sentences[0] || newText,
            sentences: sentences,
            is_active: true
          };
          console.log("[MaiTribe] inserting identity:", JSON.stringify(insertPayload));
          result = await appState.supabase.from("identities").insert(insertPayload).select();
        }

        const data = result && result.data;
        const error = result && result.error;

        if (error) {
          console.error("[MaiTribe] identity save error:", error);
          setStatus("identity-edit-status", error.message || t("status_could_not_save_identity"), true);
          return;
        }
        console.log("[MaiTribe] identity saved:", data);

        setStatus("identity-edit-status", t("status_identity_saved"));
        getEl("identity-edit-wrap").classList.add("hidden");
        await loadIdentityScreen();
        await loadHomeScreen();
      }

      async function registerPushNotifications() {
        if (!("serviceWorker" in navigator) || !("PushManager" in window)) {
          return { ok: false, message: t("status_push_not_supported") };
        }

        if (!appState.config.vapidPublicKey) {
          return { ok: false, message: t("status_add_vapid") };
        }

        try {
          const registration = await navigator.serviceWorker.register("/sw.js");
          const permission = await Notification.requestPermission();
          if (permission === "denied") {
            return { ok: false, message: t("status_push_permission_denied") };
          }
          if (permission !== "granted") {
            return { ok: false, message: t("status_push_not_supported") };
          }

          const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(appState.config.vapidPublicKey)
          });

          if (appState.currentUser && appState.supabase) {
            await updateUsersSafe(appState.currentUser.id, {
              push_token: JSON.stringify(subscription)
            });
          }

          return { ok: true, message: t("status_push_enabled") };
        } catch (error) {
          console.error("[MaiTribe] registerPushNotifications error:", error);
          return { ok: false, message: t("status_push_not_supported") };
        }
      }

      async function sendTestNotification() {
        try {
          var registration = await navigator.serviceWorker.ready;
          if (!registration || !registration.active) {
            return { ok: false, message: t("status_test_push_failed") };
          }
          var lang = getCurrentLanguage();
          var title = "Mai";
          var body = lang === "de" ? "Ich bin hier. Alles gut bei dir?" : "I am here. How are you doing?";
          await registration.showNotification(title, {
            body: body,
            icon: "/icon.svg",
            badge: "/icon.svg",
            tag: "maitribe-test",
            data: { url: "/" }
          });
          return { ok: true, message: t("status_test_push_sent") };
        } catch (error) {
          console.error("[MaiTribe] sendTestNotification error:", error);
          return { ok: false, message: t("status_test_push_failed") };
        }
      }

      function urlBase64ToUint8Array(base64String) {
        const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
        const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
        const rawData = atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; i += 1) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }

      function startVoiceInput() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          setStatus("auth-status", t("status_voice_not_supported"), true);
          return;
        }

        const recognition = new SpeechRecognition();
        recognition.lang = appState.profile && appState.profile.language === "de" ? "de-DE" : "en-US";
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onresult = function (event) {
          const transcript = event.results[0][0].transcript;
          appState.lastInputWasVoice = true;
          getEl("chat-input").value = transcript;
        };

        recognition.onerror = function () {
          setStatus("auth-status", t("status_could_not_capture_voice"), true);
        };

        recognition.start();
      }

      // ── Dein Spiegel: Astro & Human Design ──

      function signName(signObj) {
        if (!signObj) return "-";
        if (typeof signObj === "string") return signObj;
        return signObj.name || signObj.symbol || "-";
      }

      var _natalEnginePromise = null;
      function loadNatalEngine() {
        if (!_natalEnginePromise) {
          console.log("[MaiTribe] Loading natalengine from CDN...");
          _natalEnginePromise = import("https://cdn.jsdelivr.net/npm/natalengine@1.0.8/+esm").then(function(mod) {
            console.log("[MaiTribe] natalengine loaded, exports:", Object.keys(mod));
            return mod;
          }).catch(function(err) {
            console.warn("[MaiTribe] jsdelivr failed, trying esm.sh...", err);
            return import("https://esm.sh/natalengine@1.0.8");
          }).catch(function(err) {
            console.error("[MaiTribe] All CDN sources failed:", err);
            _natalEnginePromise = null;
            throw err;
          });
        }
        return _natalEnginePromise;
      }

      var _geocodeTimer = null;
      async function geocodeBirthPlace(query) {
        if (!query || query.length < 3) return [];
        try {
          var url = "https://nominatim.openstreetmap.org/search?format=json&limit=5&q=" + encodeURIComponent(query);
          var resp = await fetch(url, { headers: { "Accept-Language": getCurrentLanguage() || "en" } });
          if (!resp.ok) return [];
          var data = await resp.json();
          return data.map(function(item) {
            return { name: item.display_name, lat: parseFloat(item.lat), lng: parseFloat(item.lon) };
          });
        } catch (err) {
          console.error("[MaiTribe] Geocode error:", err);
          return [];
        }
      }

      async function calculateAstroHD(birthDateStr, birthTimeStr, timezoneOffset, lat, lng) {
        console.log("[MaiTribe] calculateAstroHD called:", { birthDateStr: birthDateStr, birthTimeStr: birthTimeStr, timezoneOffset: timezoneOffset, lat: lat, lng: lng });
        var engine = await loadNatalEngine();
        console.log("[MaiTribe] Engine loaded, exports:", Object.keys(engine));

        // Build a proper Date object in UTC
        var dateParts = birthDateStr.split("-").map(Number);
        var year = dateParts[0];
        var month = dateParts[1];
        var day = dateParts[2];
        var timeParts = (birthTimeStr || "12:00").split(":").map(Number);
        var hours = timeParts[0];
        var minutes = timeParts[1] || 0;
        var tz = parseFloat(timezoneOffset) || 0;
        var utcHours = hours - tz;
        var birthDate = new Date(Date.UTC(year, month - 1, day, utcHours, minutes, 0));
        console.log("[MaiTribe] Birth Date object (UTC):", birthDate.toISOString());

        var astro = null;
        try {
          if (lat && lng) {
            astro = engine.calculateAstrology(birthDate, parseFloat(lat), parseFloat(lng));
          } else {
            astro = engine.calculateAstrology(birthDate);
          }
          console.log("[MaiTribe] Astrology done. Sun:", astro && astro.sun && signName(astro.sun.sign));
        } catch (e) {
          console.error("[MaiTribe] Astrology calculation failed:", e);
        }

        var hd = null;
        try {
          hd = engine.calculateHumanDesign(birthDate);
          console.log("[MaiTribe] HD done. Type:", hd && hd.type && hd.type.name);
        } catch (e) {
          console.error("[MaiTribe] HD calculation failed:", e);
        }

        return { astro: astro, hd: hd };
      }

      async function saveBirthDataAndProfile(birthDate, birthTime, birthPlace, lat, lng, tz, astroResult, hdResult) {
        if (!appState.supabase || !appState.currentUser) return;
        var userId = appState.currentUser.id;

        var updatePayload = {
          birth_date: birthDate,
          birth_time: birthTime,
          birth_place: birthPlace,
          birth_lat: lat,
          birth_lng: lng,
          astro_profile: astroResult,
          human_design: hdResult,
          wisdom_preferences: { mode: "passive" }
        };

        var { error } = await appState.supabase.from("users").update(updatePayload).eq("id", userId);
        if (error) {
          console.error("[MaiTribe] Save birth data error:", error);
          throw error;
        }

        // Update local profile
        Object.assign(appState.profile, updatePayload);
      }

      function renderSpiegelResults(astro, hd) {
        var lang = getCurrentLanguage();

        // Big Three
        if (astro) {
          setText("spiegel-sun", signName(astro.sun && astro.sun.sign));
          setText("spiegel-moon", signName(astro.moon && astro.moon.sign));
          setText("spiegel-rising", signName(astro.rising && astro.rising.sign));

          // Planets list
          var planetsEl = getEl("spiegel-planets-list");
          if (planetsEl && astro.planets) {
            var html = "";
            var planetNames = Object.keys(astro.planets);
            planetNames.forEach(function(name) {
              var p = astro.planets[name];
              if (p && p.sign) {
                var degStr = p.degree != null ? " " + (typeof p.degree === "number" ? Math.round(p.degree) + "\u00B0" : p.degree) : "";
                html += '<div class="spiegel-row"><span class="spiegel-label">' + name.charAt(0).toUpperCase() + name.slice(1) + '</span><span class="spiegel-value">' + signName(p.sign) + degStr + '</span></div>';
              }
            });
            planetsEl.innerHTML = html;
          }
        }

        // Human Design
        if (hd) {
          var typeName = (hd.type && hd.type.name) || "-";
          setText("spiegel-hd-type-name", typeName);
          var typeDesc = (hd.type && hd.type.description) || "";
          setText("spiegel-hd-type-desc", typeDesc);

          var detailsEl = getEl("spiegel-hd-details");
          if (detailsEl) {
            var rows = "";
            if (hd.type && hd.type.strategy) rows += '<div class="spiegel-row"><span class="spiegel-label">' + t("spiegel_hd_strategy") + '</span><span class="spiegel-value">' + hd.type.strategy + '</span></div>';
            if (hd.authority && hd.authority.name) rows += '<div class="spiegel-row"><span class="spiegel-label">' + t("spiegel_hd_authority") + '</span><span class="spiegel-value">' + hd.authority.name + '</span></div>';
            if (hd.profile && hd.profile.numbers) rows += '<div class="spiegel-row"><span class="spiegel-label">' + t("spiegel_hd_profile") + '</span><span class="spiegel-value">' + hd.profile.numbers + (hd.profile.name ? " (" + hd.profile.name + ")" : "") + '</span></div>';
            if (hd.definition) rows += '<div class="spiegel-row"><span class="spiegel-label">' + t("spiegel_hd_definition") + '</span><span class="spiegel-value">' + hd.definition + '</span></div>';
            if (hd.incarnationCross && (hd.incarnationCross.fullName || hd.incarnationCross.name)) rows += '<div class="spiegel-row"><span class="spiegel-label">' + t("spiegel_hd_cross") + '</span><span class="spiegel-value">' + (hd.incarnationCross.fullName || hd.incarnationCross.name) + '</span></div>';
            detailsEl.innerHTML = rows;
          }

          // Centers
          var centersEl = getEl("spiegel-hd-centers");
          if (centersEl && hd.centers) {
            var tags = "";
            var defCenters = hd.centers.defined || [];
            var undefCenters = hd.centers.undefined || [];
            defCenters.forEach(function(c) {
              var label = (typeof c === "string") ? c : (c.name || c.theme || "");
              if (label) tags += '<span class="spiegel-center-tag defined">' + label + '</span>';
            });
            undefCenters.forEach(function(c) {
              var label = (typeof c === "string") ? c : (c.name || c.theme || "");
              if (label) tags += '<span class="spiegel-center-tag undefined">' + label + '</span>';
            });
            centersEl.innerHTML = tags;
          }
        }
      }

      function updateHomeSpiegelCard() {
        var profile = appState.profile;
        if (!profile || !profile.astro_profile) return;

        var astro = profile.astro_profile;
        var hd = profile.human_design;
        var preview = getEl("home-spiegel-preview");
        var cta = getEl("home-spiegel-cta");

        if (astro && astro.sun) {
          setText("home-spiegel-sun", signName(astro.sun && astro.sun.sign));
          setText("home-spiegel-moon", signName(astro.moon && astro.moon.sign));
          setText("home-spiegel-type", (hd && hd.type && hd.type.name) || "-");
          if (preview) preview.style.display = "grid";
          if (cta) cta.style.display = "none";
        }
      }

      async function loadSpiegelScreen() {
        var profile = appState.profile;

        // Apply i18n to static labels
        setText("spiegel-title", t("spiegel_title"));
        setText("spiegel-sub", t("spiegel_sub"));

        if (profile && profile.astro_profile && profile.human_design) {
          // Has data — show results
          getEl("spiegel-birth-form").style.display = "none";
          getEl("spiegel-loading").style.display = "none";
          getEl("spiegel-results").style.display = "block";
          renderSpiegelResults(profile.astro_profile, profile.human_design);
        } else {
          // No data — show birth form
          getEl("spiegel-birth-form").style.display = "block";
          getEl("spiegel-loading").style.display = "none";
          getEl("spiegel-results").style.display = "none";

          // Pre-fill from existing profile data if any
          if (profile && profile.birth_date) {
            getEl("spiegel-birth-date").value = profile.birth_date;
          }
          if (profile && profile.birth_time) {
            getEl("spiegel-birth-time").value = profile.birth_time.slice(0, 5);
          }
          if (profile && profile.birth_place) {
            getEl("spiegel-birth-place").value = profile.birth_place;
          }
        }
      }

      async function handleSpiegelCalculate() {
        var dateVal = getEl("spiegel-birth-date").value;
        var timeVal = getEl("spiegel-birth-time").value || "12:00";
        var tzVal = parseInt(getEl("spiegel-birth-tz").value) || 0;
        var placeVal = getEl("spiegel-birth-place").value.trim();

        if (!dateVal) {
          setStatus("spiegel-form-status", t("spiegel_enter_date"), true);
          return;
        }
        if (!placeVal) {
          setStatus("spiegel-form-status", t("spiegel_enter_place"), true);
          return;
        }

        // Get lat/lng
        var lat = null;
        var lng = null;
        if (appState._spiegelSelectedPlace) {
          lat = appState._spiegelSelectedPlace.lat;
          lng = appState._spiegelSelectedPlace.lng;
        } else {
          // Try geocoding
          var results = await geocodeBirthPlace(placeVal);
          if (results.length) {
            lat = results[0].lat;
            lng = results[0].lng;
          }
        }

        // Show loading
        getEl("spiegel-birth-form").style.display = "none";
        getEl("spiegel-loading").style.display = "block";
        setText("spiegel-loading-text", t("spiegel_loading"));

        try {
          var result = await calculateAstroHD(dateVal, timeVal, tzVal, lat, lng);

          // Show results immediately (even if save fails)
          getEl("spiegel-loading").style.display = "none";
          getEl("spiegel-results").style.display = "block";
          renderSpiegelResults(result.astro, result.hd);

          // Store locally so home card and system prompt can use it
          if (appState.profile) {
            appState.profile.astro_profile = result.astro;
            appState.profile.human_design = result.hd;
            appState.profile.wisdom_preferences = { mode: "passive" };
          }
          updateHomeSpiegelCard();

          // Try to save to Supabase (non-blocking)
          saveBirthDataAndProfile(dateVal, timeVal, placeVal, lat, lng, tzVal, result.astro, result.hd).catch(function(err) {
            console.warn("[MaiTribe] Could not save birth data to DB (migration may not be run yet):", err.message || err);
          });

          console.log("[MaiTribe] Astro/HD calculated successfully");
        } catch (err) {
          console.error("[MaiTribe] Spiegel calculation error:", err);
          console.error("[MaiTribe] Error name:", err && err.name, "message:", err && err.message);
          console.error("[MaiTribe] Error stack:", err && err.stack);
          getEl("spiegel-loading").style.display = "none";
          getEl("spiegel-birth-form").style.display = "block";
          var errorMsg = t("spiegel_calc_error");
          if (err && err.message) errorMsg += " (" + err.message + ")";
          setStatus("spiegel-form-status", errorMsg, true);
        }
      }

      function buildAstroContext(user) {
        if (!user) return "";
        var astro = user.astro_profile;
        var hd = user.human_design;
        var prefs = user.wisdom_preferences;
        if (!prefs || prefs.mode === "off") return "";
        if (!astro && !hd) return "";

        var langCode = user.language || getCurrentLanguage() || "en";
        var ctx = "";

        if (langCode === "de") {
          ctx += "\n\nKOSMISCHES PROFIL (Hintergrundwissen \u2014 NIEMALS ungefragt erw\u00E4hnen):";
          if (astro && astro.sun) {
            ctx += "\nSonne: " + signName(astro.sun.sign);
            if (astro.moon) ctx += " | Mond: " + signName(astro.moon.sign);
            if (astro.rising) ctx += " | Aszendent: " + signName(astro.rising.sign);
          }
          if (hd && hd.type) {
            ctx += "\nHD-Typ: " + hd.type.name;
            if (hd.type.strategy) ctx += " | Strategie: " + hd.type.strategy;
            if (hd.authority && hd.authority.name) ctx += " | Autorit\u00E4t: " + hd.authority.name;
            if (hd.profile && hd.profile.numbers) ctx += " | Profil: " + hd.profile.numbers;
          }
          ctx += "\n\nREGELN F\u00DCR KOSMISCHES WISSEN:";
          ctx += "\n- Erw\u00E4hne Astrologie oder Human Design NIEMALS von dir aus.";
          ctx += "\n- Nutze dieses Wissen nur subtil im Hintergrund \u2014 z.B. um Energie-Muster besser zu verstehen.";
          ctx += "\n- Nur wenn die Person EXPLIZIT nach Astrologie, Transiten oder Human Design fragt, darfst du es direkt benennen.";
          ctx += "\n- Die Identit\u00E4t der Person hat IMMER Vorrang vor jeder kosmischen Interpretation.";
          ctx += "\n- Keine deterministischen Aussagen. Keine Horoskop-Sprache.";
        } else {
          ctx += "\n\nCOSMIC PROFILE (Background knowledge \u2014 NEVER mention unprompted):";
          if (astro && astro.sun) {
            ctx += "\nSun: " + signName(astro.sun.sign);
            if (astro.moon) ctx += " | Moon: " + signName(astro.moon.sign);
            if (astro.rising) ctx += " | Rising: " + signName(astro.rising.sign);
          }
          if (hd && hd.type) {
            ctx += "\nHD Type: " + hd.type.name;
            if (hd.type.strategy) ctx += " | Strategy: " + hd.type.strategy;
            if (hd.authority && hd.authority.name) ctx += " | Authority: " + hd.authority.name;
            if (hd.profile && hd.profile.numbers) ctx += " | Profile: " + hd.profile.numbers;
          }
          ctx += "\n\nRULES FOR COSMIC KNOWLEDGE:";
          ctx += "\n- NEVER mention astrology or Human Design on your own.";
          ctx += "\n- Use this knowledge only subtly in the background \u2014 e.g. to better understand energy patterns.";
          ctx += "\n- Only if the person EXPLICITLY asks about astrology, transits, or Human Design may you name it directly.";
          ctx += "\n- The person\u2019s identity ALWAYS takes precedence over any cosmic interpretation.";
          ctx += "\n- No deterministic statements. No horoscope language.";
        }

        return ctx;
      }

      function generateShareText(astro, hd, lang) {
        var text = "";
        if (lang === "de") {
          text = "Mein kosmisches Profil:\n";
          if (astro && astro.sun) text += "\u2609 Sonne: " + signName(astro.sun.sign) + "\n";
          if (astro && astro.moon) text += "\u263D Mond: " + signName(astro.moon.sign) + "\n";
          if (astro && astro.rising) text += "\u2191 Aszendent: " + signName(astro.rising.sign) + "\n";
          if (hd && hd.type) text += "\u25C8 HD-Typ: " + hd.type.name + "\n";
          if (hd && hd.profile) text += "Profil: " + hd.profile.numbers + "\n";
          text += "\nEntdecke dein Profil auf MaiTribe!";
        } else {
          text = "My cosmic profile:\n";
          if (astro && astro.sun) text += "\u2609 Sun: " + signName(astro.sun.sign) + "\n";
          if (astro && astro.moon) text += "\u263D Moon: " + signName(astro.moon.sign) + "\n";
          if (astro && astro.rising) text += "\u2191 Rising: " + signName(astro.rising.sign) + "\n";
          if (hd && hd.type) text += "\u25C8 HD Type: " + hd.type.name + "\n";
          if (hd && hd.profile) text += "Profile: " + hd.profile.numbers + "\n";
          text += "\nDiscover your profile on MaiTribe!";
        }
        return text;
      }

      function bindEvents() {
        updateRangeOutputs("onboard");
        updateRangeOutputs("checkin");
        getEl("onboard-language").addEventListener("change", () => {
          applyI18n();
        });

        getEl("btn-save-config").addEventListener("click", async () => {
          const config = {
            supabaseUrl: getEl("cfg-supabase-url").value.trim(),
            supabaseAnonKey: getEl("cfg-supabase-key").value.trim(),
            geminiApiKey: getEl("cfg-gemini-key").value.trim(),
            vapidPublicKey: getEl("cfg-vapid-key").value.trim()
          };

          saveConfig(config);
          const ok = await initializeSupabase();
          if (ok) {
            setStatus("config-status", t("status_saved_continue"));
          } else {
            setStatus("config-status", t("status_missing_supabase"), true);
          }
        });

        getEl("btn-magic-link").addEventListener("click", async () => {
          if (!appState.supabase) {
            setStatus("auth-status", t("status_configure_supabase"), true);
            return;
          }

          const email = getEl("auth-email").value.trim();
          if (!email) {
            setStatus("auth-status", t("status_enter_email"), true);
            return;
          }

          setStatus("auth-status", t("status_sending_magic"));
          const { error } = await appState.supabase.auth.signInWithOtp({
            email: email,
            options: { emailRedirectTo: window.location.origin + window.location.pathname }
          });

          if (error) {
            var msg = (error.message || "").toLowerCase();
            if (msg.includes("rate limit") || msg.includes("rate_limit") || msg.includes("too many") || error.status === 429) {
              setStatus("auth-status", t("status_email_rate_limit"), true);
            } else {
              setStatus("auth-status", error.message || t("status_could_not_send_magic"), true);
            }
            return;
          }

          setStatus("auth-status", t("status_check_inbox"));
        });

        getEl("btn-google").addEventListener("click", async () => {
          if (!appState.supabase) {
            setStatus("auth-status", t("status_configure_supabase"), true);
            return;
          }

          const { error } = await appState.supabase.auth.signInWithOAuth({
            provider: "google",
            options: { redirectTo: getAuthRedirectUrl() }
          });

          if (error) {
            setStatus("auth-status", error.message || t("status_google_failed"), true);
          }
        });

        getEl("btn-onboard-begin").addEventListener("click", () => setOnboardingStep(2));

        getEl("btn-onboard-step2").addEventListener("click", () => {
          const name = getEl("onboard-name").value.trim();
          if (!name) {
            setStatus("auth-status", t("status_share_name"), true);
            return;
          }
          setOnboardingStep(3);
        });

        getEl("btn-onboard-checkin").addEventListener("click", async () => {
          await submitCheckinFromScreen("onboard");
        });

        getEl("btn-onboard-step3-next").addEventListener("click", () => {
          setOnboardingStep(4);
        });

        getEl("btn-identity-next").addEventListener("click", async () => {
          const answer = getEl("identity-answer").value.trim();
          if (!answer) {
            setStatus("identity-status", t("status_add_answer"), true);
            return;
          }

          appState.onboarding.answers.push(answer);
          setStatus("identity-status", "", false);

          if (appState.onboarding.answers.length < getIdentityQuestions().length) {
            renderIdentityQuestion();
            return;
          }

          setStatus("identity-status", t("status_generating_identity"));
          await generateIdentityFromAnswers();
        });

        getEl("btn-identity-accept").addEventListener("click", () => {
          if (!getEl("identity-generated").value.trim()) {
            setStatus("identity-status", t("status_identity_text_empty"), true);
            return;
          }
          setOnboardingStep(5);
        });

        getEl("btn-request-notifications").addEventListener("click", async () => {
          const result = await registerPushNotifications();
          setStatus("onboard-finish-status", result.message, !result.ok);
        });

        getEl("btn-onboard-finish").addEventListener("click", async () => {
          await completeOnboarding();
        });

        getEl("btn-home-checkin").addEventListener("click", () => showScreen("screen-checkin"));
        getEl("btn-home-chat").addEventListener("click", async () => {
          showScreen("screen-chat");
          await initChat();
        });

        getEl("home-identity-card").addEventListener("click", async () => {
          await loadIdentityScreen();
          showScreen("screen-identity");
        });
        getEl("home-identity-card").addEventListener("keypress", async (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            await loadIdentityScreen();
            showScreen("screen-identity");
          }
        });

        getEl("btn-chat-new").addEventListener("click", async () => {
          // Extract memories from current conversation before starting new one
          var convId = appState.currentConversationId;
          var uid = appState.currentUser && appState.currentUser.id;
          if (convId && uid) {
            var lang = (appState.profile && appState.profile.language) || getCurrentLanguage() || "en";
            extractAndSaveMemories(convId, uid, lang).catch(function(err) {
              console.error("[MaiTribe] Memory extraction on new chat:", err);
            });
          }
          // Mark current conversation as inactive and start fresh
          if (appState.currentConversationId) {
            await appState.supabase.from("conversations").update({ is_active: false }).eq("id", appState.currentConversationId);
          }
          appState.currentConversationId = null;
          await initChat();
        });

        document.addEventListener("visibilitychange", function() {
          if (document.visibilityState === "hidden" && !_memoryExtractionPending) {
            var convId = appState.currentConversationId;
            var uid = appState.user && appState.user.id;
            if (convId && uid && !_memoryExtractionDone[convId]) {
              _memoryExtractionPending = true;
              var lang = (appState.profile && appState.profile.language) || getCurrentLanguage() || "en";
              extractAndSaveMemories(convId, uid, lang).catch(function(err) {
                console.error("[MaiTribe] Visibility memory extraction failed:", err);
              }).finally(function() {
                _memoryExtractionPending = false;
              });
            }
          }
        });

        getEl("chat-form").addEventListener("submit", async (event) => {
          event.preventDefault();
          const input = getEl("chat-input");
          const text = input.value;
          input.value = "";
          await sendMessage(text);
          appState.lastInputWasVoice = false;
        });

        getEl("btn-checkin-back").addEventListener("click", () => showScreen("screen-home"));
        getEl("btn-checkin-submit").addEventListener("click", async () => {
          await submitCheckinFromScreen("checkin");
        });

        getEl("btn-identity-back").addEventListener("click", () => showScreen("screen-home"));
        getEl("btn-identity-edit").addEventListener("click", () => {
          getEl("identity-edit-wrap").classList.remove("hidden");
          getEl("identity-edit-text").focus();
        });
        getEl("btn-identity-cancel").addEventListener("click", () => {
          getEl("identity-edit-wrap").classList.add("hidden");
          setStatus("identity-edit-status", "", false);
        });
        getEl("btn-identity-save").addEventListener("click", saveIdentityEdit);

        // ── Dein Spiegel events ──
        getEl("btn-spiegel-back").addEventListener("click", function() {
          showScreen("screen-home");
        });

        getEl("home-spiegel-card").addEventListener("click", async function() {
          await loadSpiegelScreen();
          showScreen("screen-spiegel");
        });
        getEl("home-spiegel-card").addEventListener("keypress", async function(event) {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            await loadSpiegelScreen();
            showScreen("screen-spiegel");
          }
        });

        getEl("btn-spiegel-calculate").addEventListener("click", handleSpiegelCalculate);

        getEl("btn-spiegel-skip").addEventListener("click", function() {
          showScreen("screen-home");
        });

        getEl("btn-spiegel-edit").addEventListener("click", function() {
          getEl("spiegel-results").style.display = "none";
          getEl("spiegel-birth-form").style.display = "block";
          setStatus("spiegel-form-status", "", false);
        });

        // Geocode autocomplete for birth place
        getEl("spiegel-birth-place").addEventListener("input", function() {
          var val = this.value.trim();
          clearTimeout(_geocodeTimer);
          var resultsEl = getEl("spiegel-place-results");
          if (val.length < 3) {
            resultsEl.style.display = "none";
            return;
          }
          _geocodeTimer = setTimeout(async function() {
            var results = await geocodeBirthPlace(val);
            if (!results.length) {
              resultsEl.style.display = "none";
              return;
            }
            resultsEl.innerHTML = "";
            results.forEach(function(place) {
              var item = document.createElement("div");
              item.style.cssText = "padding:8px 12px;cursor:pointer;font-size:13px;border-bottom:1px solid var(--line);";
              item.textContent = place.name;
              item.addEventListener("click", function() {
                getEl("spiegel-birth-place").value = place.name;
                appState._spiegelSelectedPlace = { lat: place.lat, lng: place.lng };
                resultsEl.style.display = "none";
              });
              resultsEl.appendChild(item);
            });
            resultsEl.style.display = "block";
          }, 500);
        });

        // Share button
        getEl("btn-spiegel-share").addEventListener("click", async function() {
          var profile = appState.profile;
          if (!profile || !profile.astro_profile) return;
          var lang = getCurrentLanguage();
          var text = generateShareText(profile.astro_profile, profile.human_design, lang);
          if (navigator.share) {
            try {
              await navigator.share({ title: "MaiTribe - " + t("spiegel_title"), text: text });
            } catch (e) {
              // User cancelled share
            }
          } else {
            // Fallback: copy to clipboard
            try {
              await navigator.clipboard.writeText(text);
              setStatus("spiegel-form-status", lang === "de" ? "In Zwischenablage kopiert!" : "Copied to clipboard!", false);
            } catch (e) {
              console.error("[MaiTribe] Share fallback error:", e);
            }
          }
        });

        getEl("settings-spiegel-link").addEventListener("click", async function() {
          await loadSpiegelScreen();
          showScreen("screen-spiegel");
        });

        getEl("btn-settings-save").addEventListener("click", saveSettings);
        getEl("btn-settings-push").addEventListener("click", async () => {
          const result = await registerPushNotifications();
          setStatus("settings-status", result.message, !result.ok);
        });

        getEl("btn-settings-test-push").addEventListener("click", async () => {
          const result = await sendTestNotification();
          setStatus("settings-status", result.message, !result.ok);
        });

        getEl("btn-logout").addEventListener("click", async () => {
          if (!appState.supabase) return;
          await appState.supabase.auth.signOut();
          appState.session = null;
          appState.currentUser = null;
          appState.currentConversationId = null;
          appState.profile = null;
          showScreen("screen-auth");
        });

        getEl("bottom-nav").querySelectorAll("button").forEach((button) => {
          button.addEventListener("click", async () => {
            const target = button.getAttribute("data-target");
            // Extract memories when leaving chat screen
            if (target !== "screen-chat" && appState.currentConversationId) {
              var convId = appState.currentConversationId;
              var uid = appState.currentUser && appState.currentUser.id;
              if (convId && uid) {
                var lang = (appState.profile && appState.profile.language) || getCurrentLanguage() || "en";
                extractAndSaveMemories(convId, uid, lang).catch(function(err) {
                  console.error("[MaiTribe] Nav memory extraction:", err);
                });
              }
            }
            if (target === "screen-chat") {
              showScreen("screen-chat");
              await initChat();
              return;
            }
            if (target === "screen-home") {
              await loadHomeScreen();
            }
            if (target === "screen-settings") {
              await loadProfile();
              populateSettingsFromProfile();
            }
            showScreen(target);
          });
        });
      }

      var _authListenerRegistered = false;
      var _bootRouteComplete = false;

      function registerAuthListener() {
        if (!appState.supabase) return;
        if (_authListenerRegistered) return;
        _authListenerRegistered = true;
        appState.supabase.auth.onAuthStateChange(async (event, session) => {
          console.log("[MaiTribe] onAuthStateChange:", event, session ? session.user.email : "no session");
          // During boot, let routeAfterSplash handle the initial session check.
          // Only react to auth changes AFTER boot routing is complete.
          if (!_bootRouteComplete) return;
          if (session) {
            await handleSession(session);
          } else {
            appState.session = null;
            appState.currentUser = null;
            appState.profile = null;
            showScreen("screen-auth");
          }
        });
      }

      // --- Add to Homescreen prompt ---
      var _deferredA2hsPrompt = null;

      window.addEventListener("beforeinstallprompt", function(e) {
        e.preventDefault();
        _deferredA2hsPrompt = e;
        // Don't show during onboarding — wait until user is on home screen
        if (localStorage.getItem("maitribe.a2hs.dismissed")) return;
        setTimeout(function() {
          var banner = getEl("a2hs-banner");
          var textEl = getEl("a2hs-text");
          var installBtn = getEl("a2hs-install");
          if (textEl) textEl.textContent = t("a2hs_text");
          if (installBtn) installBtn.textContent = t("a2hs_install");
          if (banner) banner.classList.add("visible");
        }, 3000);
      });

      if (getEl("a2hs-install")) {
        getEl("a2hs-install").addEventListener("click", async function() {
          if (!_deferredA2hsPrompt) return;
          _deferredA2hsPrompt.prompt();
          var result = await _deferredA2hsPrompt.userChoice;
          _deferredA2hsPrompt = null;
          getEl("a2hs-banner").classList.remove("visible");
          if (result.outcome === "accepted") {
            localStorage.setItem("maitribe.a2hs.dismissed", "installed");
          }
        });
      }

      if (getEl("a2hs-close")) {
        getEl("a2hs-close").addEventListener("click", function() {
          getEl("a2hs-banner").classList.remove("visible");
          localStorage.setItem("maitribe.a2hs.dismissed", "1");
        });
      }

      async function boot() {
        fillConfigInputs();
        bindEvents();

        getEl("onboard-language").value = detectDefaultLanguage();
        getEl("onboard-timezone").value = detectTimezone();
        applyI18n();

        const params = new URLSearchParams(window.location.search);
        const disableSw = params.get("no_sw") === "1";

        if ("serviceWorker" in navigator) {
          if (disableSw) {
            navigator.serviceWorker.getRegistrations()
              .then((registrations) => Promise.all(registrations.map((registration) => registration.unregister())))
              .catch(() => {});
          } else {
            navigator.serviceWorker.register("/sw.js").catch(() => {});
          }
        }

        setTimeout(routeAfterSplash, 2000);
        setTimeout(() => {
          const splash = getEl("screen-splash");
          if (splash && splash.classList.contains("active")) {
            showScreen("screen-auth");
            setStatus("config-status", t("status_app_start_fail"), true);
          }
        }, 6000);
      }

      boot();
    })();
  </script>
</body>
</html>
